<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P2P Chat — Distributed Messaging</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="shared-background.css">
    <link rel="stylesheet" href="chating.css">
    <link rel="stylesheet" href="imo-sidebar.css">

    <style>
        /* Additional styles for call and file features */
        .file-preview {
            background: var(--panel-bg, rgba(255, 255, 255, 0.9));
            border-radius: 10px;
            padding: 10px;
            margin: 5px 0;
            border: 1px solid var(--panel-border, rgba(0, 0, 0, 0.06));
        }

        .file-preview img {
            max-width: 200px;
            max-height: 150px;
            border-radius: 5px;
        }

        .file-info {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px;
        }

        .file-icon {
            font-size: 24px;
            color: var(--primary);
        }

        .file-details {
            flex: 1;
        }

        .file-name {
            font-weight: 500;
            font-size: 14px;
        }

        .file-size {
            font-size: 12px;
            color: var(--gray);
        }

        .download-btn {
            background: var(--primary);
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
        }

        .call-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 3000;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
        }

        .call-container.active {
            display: flex;
        }

        .video-container {
            width: 90%;
            max-width: 800px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }

        .video-box {
            background: #2c3e50;
            border-radius: 10px;
            overflow: hidden;
            position: relative;
            aspect-ratio: 4/3;
        }

        .video-box video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .video-label {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 12px;
        }

        .call-controls {
            display: flex;
            gap: 20px;
            margin-top: 20px;
        }

        .call-control-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: none;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .call-accept {
            background: var(--success);
            color: white;
        }

        .call-reject {
            background: var(--danger);
            color: white;
        }

        .call-end {
            background: var(--danger);
            color: white;
        }

        .call-mute {
            background: var(--warning);
            color: white;
        }

        .call-video {
            background: var(--primary);
            color: white;
        }

        .call-control-btn:hover {
            transform: scale(1.1);
        }

        .incoming-call-alert {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--panel-bg, rgba(255, 255, 255, 0.95));
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            z-index: 4000;
            text-align: center;
            display: none;
        }

        .incoming-call-alert.active {
            display: block;
        }

        .caller-info {
            margin-bottom: 20px;
        }

        .caller-avatar {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            margin: 0 auto 10px;
        }

        .file-progress {
            width: 100%;
            height: 4px;
            background: #e0e0e0;
            border-radius: 2px;
            margin-top: 5px;
            overflow: hidden;
        }

        .file-progress-bar {
            height: 100%;
            background: var(--primary);
            width: 0%;
            transition: width 0.3s ease;
        }

        /* Hide the inline msg-actions by default to avoid clutter.
                    Show actions on message hover or when the options menu is open. */
        .msg-actions {
            display: none;
        }

        /* Show action buttons on hover for any message (incoming or outgoing) */
        .message:hover .msg-actions {
            display: inline-block;
        }

        .msg-menu {
            z-index: 2000;
        }

        .msg-status {
            margin-left: 8px;
            font-size: 14px;
            color: inherit;
            /* ensure emoji glyphs render on platforms that support color emoji */
            font-family: "Segoe UI Emoji", "Apple Color Emoji", "Noto Color Emoji", "Segoe UI", sans-serif;
            display: outline-none;
            min-width: 18px;
            text-align: right;
            vertical-align: middle;
        }

        /* Pending / unseen: subtle grey single check (or minimal mark) */
        .msg-status.pending::after {
            /* CSS uses hex escapes (no 'u' prefix) */
            content: "\2713"; /* ✓ */
            color: #9aa0a6;
            font-weight: 600;
            opacity: 0.9;
        }

        /* Delivered (server ack): single green check emoji */
        .msg-status.delivered::after {
            content: "\2705"; /* ✅ */
            color: #28a745;
        }

        /* Seen / read: double check marks (highlighted) */
        .msg-status.seen::after {
            content: "\2705\2705"; /* ✅✅ */
            color: var(--primary, #007bff);
        }

        /* Friend Request Styles */
        .no-friends-message {
            text-align: center;
            padding: 30px 20px;
            color: var(--gray);
        }

        .no-friends-message i {
            font-size: 40px;
            margin-bottom: 10px;
            opacity: 0.5;
        }

        .no-friends-message p {
            margin: 5px 0;
            font-weight: 500;
        }

        .no-friends-message small {
            font-size: 12px;
        }

        .friend-badge {
            color: var(--primary);
            font-size: 12px;
        }

        .badge {
            background: var(--danger);
            color: white;
            border-radius: 10px;
            padding: 2px 8px;
            font-size: 12px;
            margin-left: 5px;
        }

        .friend-requests-tabs {
            display: flex;
            border-bottom: 1px solid var(--border-color);
            margin-bottom: 15px;
        }

        .tab-btn {
            flex: 1;
            padding: 10px;
            background: none;
            border: none;
            cursor: pointer;
            border-bottom: 2px solid transparent;
        }

        .tab-btn.active {
            border-bottom-color: var(--primary);
            color: var(--primary);
            font-weight: 500;
        }

        .tab-content {
            display: none;
            max-height: 300px;
            overflow-y: auto;
        }

        .tab-content.active {
            display: block;
        }

        .friend-request-item {
            display: flex;
            align-items: center;
            padding: 10px;
            border-bottom: 1px solid var(--border-color);
        }

        .friend-request-item img {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            margin-right: 10px;
        }

        .friend-request-info {
            flex: 1;
        }

        .friend-request-actions {
            display: flex;
            gap: 5px;
        }

        .friend-request-actions button {
            padding: 5px 10px;
            font-size: 12px;
        }

        .search-controls {
            margin-bottom: 15px;
        }

        .discover-user-item {
            display: flex;
            align-items: center;
            padding: 10px;
            border-bottom: 1px solid var(--border-color);
        }

        .discover-user-item img {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            margin-right: 10px;
        }

        .discover-user-info {
            flex: 1;
        }

        .discover-user-status {
            font-size: 12px;
            color: var(--gray);
        }

        .btn-add-friend {
            background: var(--primary);
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
        }

        .btn-add-friend:disabled {
            background: var(--gray);
            cursor: not-allowed;
        }

        /* Sidebar tabs */
        .sidebar-tabs {
            display: flex;
            border-bottom: 1px solid #e0e0e0;
            margin: 0 10px 10px 10px;
            background: rgba(255, 255, 255, 0.5);
        }

        .sidebar-tabs .tab-button {
            flex: 1;
            padding: 10px 8px;
            background: none;
            border: none;
            border-bottom: 2px solid transparent;
            cursor: pointer;
            font-size: 13px;
            color: #666;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
        }

        .sidebar-tabs .tab-button.active {
            color: var(--primary, #007bff);
            border-bottom-color: var(--primary, #007bff);
            font-weight: 500;
        }

        .sidebar-tabs .tab-button:hover {
            color: var(--primary, #007bff);
            background: rgba(0, 123, 255, 0.05);
        }

        /* All users container in sidebar */
        #all-users-container {
            overflow-y: auto;
            height: calc(100vh - 380px);
        }

        #all-users-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        /* Compact user item styling for sidebar */
        #all-users-list .contact-item {
            display: flex;
            align-items: center;
            padding: 10px 15px;
            border-bottom: 1px solid #f0f0f0;
            cursor: pointer;
            transition: background 0.2s;
        }

        #all-users-list .contact-item:hover {
            background: #f9f9f9;
        }

        #all-users-list .contact-item img {
            width: 45px;
            height: 45px;
            border-radius: 50%;
            object-fit: cover;
            margin-right: 12px;
        }

        #all-users-list .meta {
            flex: 1;
            min-width: 0;
        }

        #all-users-list .status-badge {
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 10px;
            margin-left: 5px;
            font-weight: 500;
        }

        #all-users-list .status-badge.friend {
            background: #d4edda;
            color: #155724;
        }

        #all-users-list .status-badge.request_sent {
            background: #fff3cd;
            color: #856404;
        }

        #all-users-list .status-badge.request_received {
            background: #cce5ff;
            color: #004085;
        }

        #all-users-list .user-actions {
            display: flex;
            gap: 5px;
            flex-shrink: 0;
        }

        #all-users-list .btn-small {
            padding: 4px 8px;
            font-size: 11px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }

        #all-users-list .btn-chat {
            background: #28a745;
            color: white;
        }

        #all-users-list .btn-add {
            background: #007bff;
            color: white;
        }

        #all-users-list .btn-accept {
            background: #28a745;
            color: white;
        }

        #all-users-list .btn-reject,
        #all-users-list .btn-cancel {
            background: #dc3545;
            color: white;
        }

        #all-users-list .btn-small:hover {
            opacity: 0.9;
            transform: scale(1.05);
        }

        /* Forward Dialog Styles */
        .forward-dialog {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 3000;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .forward-dialog.hidden {
            display: none;
        }

        .dialog-backdrop {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(4px);
        }

        .dialog-content {
            position: relative;
            background: var(--panel-bg, #fff);
            border-radius: 16px;
            width: 90%;
            max-width: 450px;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            animation: slideInUp 0.3s ease;
        }

        @keyframes slideInUp {
            from {
                transform: translateY(50px);
                opacity: 0;
            }

            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .dialog-header {
            padding: 20px;
            border-bottom: 1px solid var(--panel-border, #e0e0e0);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .dialog-header h3 {
            margin: 0;
            font-size: 18px;
            font-weight: 600;
        }

        .btn-close {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: var(--gray);
            padding: 0;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.2s;
        }

        .btn-close:hover {
            background: rgba(0, 0, 0, 0.05);
        }

        .dialog-body {
            padding: 20px;
            flex: 1;
            overflow-y: auto;
        }

        .search-input {
            width: 100%;
            padding: 10px 15px;
            border: 1px solid var(--panel-border, #ddd);
            border-radius: 8px;
            font-size: 14px;
            margin-bottom: 15px;
            outline: none;
            transition: border-color 0.2s;
        }

        .search-input:focus {
            border-color: var(--primary);
        }

        .friends-select-list {
            max-height: 300px;
            overflow-y: auto;
        }

        .friend-select-item {
            display: flex;
            align-items: center;
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .friend-select-item:hover {
            background: rgba(0, 0, 0, 0.03);
        }

        .friend-select-item input[type="checkbox"] {
            margin-right: 12px;
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .friend-select-item img {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            margin-right: 12px;
        }

        .friend-select-item .name {
            font-weight: 500;
            font-size: 14px;
        }

        .dialog-footer {
            padding: 15px 20px;
            border-top: 1px solid var(--panel-border, #e0e0e0);
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn.primary {
            background: var(--primary);
            color: white;
        }

        .btn.primary:hover {
            opacity: 0.9;
            transform: translateY(-1px);
        }

        .btn:not(.primary) {
            background: #f0f0f0;
            color: #333;
        }

        .btn:not(.primary):hover {
            background: #e0e0e0;
        }

        /* Voice Recording UI Styles */
        .voice-recording-ui {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
            transform: translateY(100%);
            transition: transform 0.3s ease;
            z-index: 2500;
            box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.2);
        }

        .voice-recording-ui:not(.hidden) {
            transform: translateY(0);
        }

        .voice-recording-ui.hidden {
            display: block;
        }

        .recording-content {
            max-width: 600px;
            margin: 0 auto;
            text-align: center;
            color: white;
        }

        .recording-header {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            margin-bottom: 15px;
        }

        .recording-icon {
            font-size: 24px;
        }

        .recording-icon.pulsing {
            animation: pulse 1.5s ease-in-out infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
                transform: scale(1);
            }

            50% {
                opacity: 0.7;
                transform: scale(1.1);
            }
        }

        .recording-text {
            font-size: 18px;
            font-weight: 600;
        }

        .recording-timer {
            font-size: 48px;
            font-weight: 700;
            margin: 20px 0;
            font-family: 'Courier New', monospace;
            letter-spacing: 4px;
        }

        .recording-waveform {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
            height: 60px;
            margin: 20px 0;
        }

        .wave-bar {
            width: 4px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 2px;
            animation: wave 1s ease-in-out infinite;
        }

        .wave-bar:nth-child(1) {
            animation-delay: 0s;
            height: 20px;
        }

        .wave-bar:nth-child(2) {
            animation-delay: 0.1s;
            height: 30px;
        }

        .wave-bar:nth-child(3) {
            animation-delay: 0.2s;
            height: 40px;
        }

        .wave-bar:nth-child(4) {
            animation-delay: 0.3s;
            height: 30px;
        }

        .wave-bar:nth-child(5) {
            animation-delay: 0.4s;
            height: 20px;
        }

        @keyframes wave {

            0%,
            100% {
                height: 20px;
            }

            50% {
                height: 50px;
            }
        }

        .recording-controls {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-top: 20px;
        }

        .btn-icon {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            transition: all 0.2s;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            backdrop-filter: blur(10px);
        }

        .btn-icon:hover {
            transform: scale(1.1);
            background: rgba(255, 255, 255, 0.3);
        }

        .btn-icon.primary {
            background: #4CAF50;
        }

        .btn-icon.primary:hover {
            background: #45a049;
        }

        /* Voice Message Player Styles */
        .voice-message {
            background: var(--panel-bg, rgba(255, 255, 255, 0.9));
            border-radius: 20px;
            padding: 12px 16px;
            display: flex;
            align-items: center;
            gap: 12px;
            max-width: 300px;
        }

        .voice-play-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: none;
            background: var(--primary);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            flex-shrink: 0;
            transition: all 0.2s;
        }

        .voice-play-btn:hover {
            transform: scale(1.05);
        }

        .voice-progress {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .voice-progress-bar {
            width: 100%;
            height: 4px;
            background: rgba(0, 0, 0, 0.1);
            border-radius: 2px;
            overflow: hidden;
            cursor: pointer;
        }

        .voice-progress-fill {
            height: 100%;
            background: var(--primary);
            width: 0%;
            transition: width 0.1s linear;
        }

        .voice-time {
            font-size: 11px;
            color: var(--gray);
        }

        /* Forwarded Message Indicator (IMO-style) */
        .forwarded-indicator {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 11px;
            color: #666;
            font-style: italic;
            margin-bottom: 4px;
            padding: 4px 0;
        }

        .forwarded-indicator i {
            font-size: 12px;
            color: #888;
        }

        .message.outgoing .forwarded-indicator {
            color: rgba(255, 255, 255, 0.8);
        }

        .message.outgoing .forwarded-indicator i {
            color: rgba(255, 255, 255, 0.9);
        }

        /* Voice recording button style */
        #voice-record-btn {
            background: none;
            border: none;
            color: var(--primary);
            font-size: 20px;
            cursor: pointer;
            padding: 8px 12px;
            transition: all 0.2s;
        }

        #voice-record-btn:hover {
            transform: scale(1.1);
            color: var(--primary-dark, #6e49cb);
        }

        #voice-record-btn.recording {
            color: #f44336;
            animation: pulse 1.5s ease-in-out infinite;
        }
        
        /* Sidebar profile mini adjustments */
        .sidebar-header .profile-mini {
            width: 68px;
            height: 68px;
            margin-bottom: 14px;
            display: inline-block;
            overflow: hidden;
            border-radius: 50%;
            flex-shrink: 0;
        }

        .sidebar-header .profile-mini img {
            width: 68px;
            height: 68px;
            border-radius: 60%;
            object-fit: cover;
            display: block;
        }

        /* Small tweak to the header spacing so the activity list shows clearly */
        .sidebar-header {
            margin-bottom: 10px;
        }
    </style>
</head>

<body class="with-bg">
    <div class="top-nav-bar" id="topNav">
        <nav>
            <a href="index.html">Home</a>
            <a href="tp.html" class="active">Dashboard</a>
            <a href="profile.html">Profile</a>
            <a href="setting.html">Settings</a>
            <a href="#" id="logoutLink">Logout</a>
        </nav>
    </div>

    <!-- Animated background layers -->
    <div class="bg-visual">
        <div class="blob b1"></div>
        <div class="blob b2"></div>
        <div class="blob b3"></div>
        <div class="blob b4"></div>
        <div class="gradient-overlay"></div>
    </div>

    <div id="app">
        <!-- Sidebar / Contacts -->
        <aside id="sidebar">
            <header class="sidebar-header">
                <div class="profile-mini" id="profileMini" title="Edit profile">
                    <img id="profile-avatar" src="https://i.pravatar.cc/150?img=12" alt="You">
                    <div>
                        <div id="profile-name" class="name">Guest</div>
                    <!-- Group Info Modal -->
                    <div id="groupInfoModal" class="modal" style="display:none;align-items:center;justify-content:center;">
                        <div class="modal-content" style="max-width:520px;">
                            <div class="modal-header">
                                <div class="modal-title">Group Info</div>
                                <button class="close-modal" id="groupInfoClose">&times;</button>
                            </div>
                            <div class="modal-body">
                                <div style="display:flex;align-items:center;gap:12px;margin-bottom:10px;">
                                    <div style="width:56px;height:56px;border-radius:8px;background:#eee;display:flex;align-items:center;justify-content:center;font-weight:700;font-size:18px;" id="groupInfoAvatar">G</div>
                                    <div>
                                        <div id="groupInfoName" style="font-weight:600;font-size:16px;">Group name</div>
                                        <div id="groupInfoMeta" style="font-size:13px;color:#666;">0 members</div>
                                    </div>
                                </div>
                                <div>
                                    <h4>Members</h4>
                                    <div id="group-members-list" style="display:flex;flex-direction:column;gap:8px;max-height:320px;overflow:auto;padding-top:6px;"></div>
                                </div>
                            </div>
                            <div class="modal-footer">
                                <button class="btn btn-secondary" id="groupInfoCloseBtn">Close</button>
                            </div>
                        </div>
                    </div>

                        <div id="profile-status" class="status">Online</div>
                    </div>
                </div>
                <button id="new-chat" title="New chat">+</button>
            </header>

            <div class="search-wrap">
                <input id="search" placeholder="Search contacts" aria-label="Search contacts">
            </div>

            <div class="chat-options">
                <button id="discover-peers" class="btn primary" style="width: 100%; margin: 10px 0; padding: 10px;">
                    <i class="fas fa-search"></i> Discover Peers via DHT
                </button>

                <button id="create-group" class="btn" style="width: 100%; margin-bottom: 10px; padding: 10px;">
                    <i class="fas fa-users"></i> Create Group Chat
                </button>
            

                <!-- Friend Request Modal -->
                <div id="friendRequestModal" class="modal" style="display:none;">
                    <div class="modal-content">
                        <div class="modal-header">
                            <div class="modal-title">Friend Requests</div>
                            <button class="close-modal" id="friendRequestClose">&times;</button>
                        </div>
                        <div class="modal-body">
                            <div class="friend-requests-tabs">
                                <button class="tab-btn active" data-tab="incoming">Incoming</button>
                                <button class="tab-btn" data-tab="outgoing">Sent</button>
                                <button class="tab-btn" data-tab="discover">Discover Users</button>
                            </div>

                            <div id="incoming-requests" class="tab-content active">
                                <h4>Pending Requests</h4>
                                <div id="incoming-requests-list"></div>
                            </div>

                            <div id="outgoing-requests" class="tab-content">
                                <h4>Sent Requests</h4>
                                <div id="outgoing-requests-list"></div>
                            </div>

                            <div id="discover-users" class="tab-content">
                                <div class="search-controls">
                                    <input type="text" id="search-users" placeholder="Search users..."
                                        class="form-control">
                                </div>
                                <div id="discover-users-list"></div>
                            </div>
                        </div>
                    </div>
                </div>


                <!-- Create Group Modal trigger inserted above; modal markup follows -->
                <div id="createGroupModal" class="modal"
                    style="display:none;align-items:center;justify-content:center;">
                    <div class="modal-content" style="max-width:520px;">
                        <div class="modal-header">
                            <div class="modal-title">Create Group</div>
                            <button class="close-modal" id="createGroupClose">&times;</button>
                        </div>
                        <div class="modal-body">
                            <div class="form-group">
                                <label for="groupName">Group name</label>
                                <input id="groupName" class="form-control" placeholder="Group name (required)">
                            </div>
                            <div class="form-group">
                                <label>Select participants</label>
                                <div id="create-group-peers"
                                    style="max-height:280px;overflow:auto;padding:8px;border:1px solid #eee;border-radius:6px;background:#fff">
                                </div>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="btn btn-secondary" id="createGroupCancel">Cancel</button>
                            <button class="btn btn-primary" id="createGroupSubmit">Create Group</button>
                        </div>
                    </div>
                </div>
                <!-- Add Members Modal (for existing groups) -->
                <div id="addMembersModal" class="modal" style="display:none;align-items:center;justify-content:center;">
                    <div class="modal-content" style="max-width:520px;">
                        <div class="modal-header">
                            <div class="modal-title">Add Members to Group</div>
                            <button class="close-modal" id="addMembersClose">&times;</button>
                        </div>
                        <div class="modal-body">
                            <div class="form-group">
                                <label for="addMembersSearch">Search users</label>
                                <input id="addMembersSearch" class="form-control" placeholder="Search users to add...">
                            </div>
                            <div class="form-group">
                                <label>Select participants</label>
                                <div id="add-members-list" style="max-height:320px;overflow:auto;padding:8px;border:1px solid #eee;border-radius:6px;background:#fff">
                                </div>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="btn btn-secondary" id="addMembersCancel">Cancel</button>
                            <button class="btn btn-primary" id="addMembersSubmit">Add Members</button>
                        </div>
                    </div>
                </div>
                

            <!-- Sidebar Tabs for Friends, Groups, and All Users -->
            <div class="sidebar-tabs">
                <button class="tab-button active" id="tab-friends" data-tab="friends">
                    <i class="fas fa-user-friends"></i> Friends
                </button>
                <button class="tab-button" id="tab-groups" data-tab="groups">
                    <i class="fas fa-users"></i> Groups
                </button>
                <button class="tab-button" id="tab-all-users" data-tab="all-users">
                    <i class="fas fa-globe"></i> All Users
                </button>
            </div>

            <!-- Friends Container -->
            <ul id="peer-list" class="contacts" data-tab-content="friends">
                <!-- Friends will be loaded dynamically -->
            </ul>

            <!-- Groups Container -->
            <div id="groups-container" class="contacts" data-tab-content="groups" style="display: none;">
                <ul id="groups-list" class="contacts-list">
                    <!-- Groups will be loaded dynamically -->
                </ul>
            </div>

            <!-- All Users Container -->
            <div id="all-users-container" class="contacts" data-tab-content="all-users" style="display: none;">
                <ul id="all-users-list" class="contacts-list">
                    <!-- All users will be loaded dynamically -->
                </ul>
            </div>
        </aside>

        <!-- Main chat area -->
        <main id="main">
            <section id="empty-view">
                <div class="welcome">
                    <h1>Welcome to P2P Chat</h1>
                    <p>Select a contact to start chatting — Distributed P2P messaging with real backend integration.</p>
                    <div style="margin-top: 20px; text-align: left;">
                        <h3>Real-time Features:</h3>
                        <ul style="text-align: left; display: inline-block;">
                            <li>✅ Real User Authentication</li>
                            <li>✅ WebSocket Backend Connection</li>
                            <li>✅ Live Peer Discovery</li>
                            <li>✅ Instant Messaging</li>
                            <li>✅ User Profile Integration</li>
                            <li>✅ Video & Audio Calls</li>
                            <li>✅ File Sharing</li>
                        </ul>
                    </div>
                </div>
            </section>

            <section id="chat-page" class="hidden">
                <header id="chat-header">
                    <button id="back-btn">⟵</button>
                    <div class="chat-info">
                        <img id="chat-avatar" src="https://i.pravatar.cc/150?img=1" alt="avatar">
                        <div>
                            <div id="chat-with">Select a peer <span id="group-indicator"
                                    class="group-indicator hidden">Group</span></div>
                            <div id="chat-presence" class="small">Offline</div>
                        </div>
                    </div>
                    <div id="screenshotWarningBanner" style="display:none;align-items:center;gap:8px;padding:6px 10px;border-radius:6px;background:#fff4e5;color:#6b3d00;margin-left:12px;font-size:13px;">
                        <span style="font-weight:600;">⚠️ Screenshot detected</span>
                        <span id="screenshotBannerMsg">A screenshot may have been taken (best-effort detection).</span>
                    </div>
                    <div id="chat-actions">
                        <button id="audio-call-btn"><i class="fas fa-phone"></i></button>
                        <!-- More menu: shows Add Members when in a group chat -->
                        <div style="display:inline-block;position:relative;">
                            <button id="chatMoreBtn" class="btn" title="More"><i class="fas fa-ellipsis-v"></i></button>
                            <div id="chatMoreMenu" style="display:none;position:absolute;right:0;top:36px;background:#fff;border:1px solid #eee;border-radius:6px;box-shadow:0 6px 18px rgba(0,0,0,0.08);min-width:160px;z-index:60;">
                                    <div id="addMembersAction" style="padding:10px;cursor:pointer;border-bottom:1px solid #f5f5f5;display:none;">Add members to group</div>
                                    <div id="viewGroupInfoAction" style="padding:10px;cursor:pointer;display:none;">View group info</div>
                            </div>
                        </div>
                        <button id="video-call-btn"><i class="fas fa-video"></i></button>
                        <input type="file" id="file-input" style="display:none;" multiple>
                        <button id="file-btn"><i class="fas fa-paperclip"></i></button>
                        <button id="group-info-btn" class="hidden"><i class="fas fa-info-circle"></i></button>
                    </div>
                </header>

                <div id="chat-messages" aria-live="polite">
                    <!-- Messages will be loaded here -->
                </div>

                <div id="chat-input-area">
                    <button id="emoji-btn"><i class="far fa-smile"></i></button>
                    <button id="voice-record-btn" title="Record voice message"><i
                            class="fas fa-microphone"></i></button>
                    <input type="text" id="message" placeholder="Type a message" autocomplete="off">
                    <select id="msgSelfDestructSelect" title="Message self-destruct timer" style="margin:0 6px;padding:6px;border-radius:6px;border:1px solid #ddd;background:white;font-size:13px;">
                        <option value="off">Off</option>
                        <option value="5s">5s</option>
                        <option value="10s">10s</option>
                        <option value="1m">1m</option>
                        <option value="1h">1h</option>
                        <option value="1d">1d</option>
                    </select>
                    <button id="send-btn">Send</button>
                </div>
            </section>
        </main>
    </div>

    <!-- In-page profile slide-over panel (IMO-style) -->
    <div id="profilePanel" class="profile-panel hidden" aria-hidden="true">
        <div class="panel-backdrop" id="panelBackdrop"></div>
        <aside class="panel">
            <header class="panel-header">
                <div class="panel-title">Profile</div>
                <button id="panelClose" class="btn">✕</button>
            </header>

            <div class="panel-body">
                <div class="panel-avatar"><img id="panelAvatar" src="https://i.pravatar.cc/150?img=12" alt="avatar">
                </div>
                <div class="panel-info">
                    <div id="panelName" class="panel-name">Guest User</div>
                    <div id="panelStatus" class="panel-status">Online</div>
                    <div class="panel-meta">
                        <div><strong>DID:</strong> <span id="panelDID">Not available</span></div>
                        <div><strong>User ID:</strong> <span id="panelUserID">Not available</span></div>
                        <div><strong>Node ID:</strong> <span id="panelNodeID">Not available</span></div>
                    </div>
                </div>

                <div class="panel-actions">
                    <button id="panelEdit" class="btn primary">Edit Profile</button>
                    <button id="panelLogout" class="btn">Log out</button>
                </div>
            </div>
        </aside>
    </div>

    <!-- Call Interface -->
    <div id="callContainer" class="call-container">
        <div class="video-container">
            <div class="video-box">
                <video id="localVideo" autoplay muted></video>
                <div class="video-label">You</div>
            </div>
            <div class="video-box">
                <video id="remoteVideo" autoplay></video>
                <div class="video-label" id="remoteUserLabel">Remote User</div>
            </div>
        </div>
        <div class="call-controls">
            <button id="muteBtn" class="call-control-btn call-mute">
                <i class="fas fa-microphone"></i>
            </button>
            <button id="videoBtn" class="call-control-btn call-video">
                <i class="fas fa-video"></i>
            </button>
            <button id="endCallBtn" class="call-control-btn call-end">
                <i class="fas fa-phone-slash"></i>
            </button>
        </div>
    </div>

    <!-- Incoming Call Alert -->
    <div id="incomingCallAlert" class="incoming-call-alert">
        <div class="caller-info">
            <img id="callerAvatar" src="" alt="Caller" class="caller-avatar">
            <h3 id="callerName">Incoming Call</h3>
            <p id="callType">Audio Call</p>
        </div>
        <div class="call-actions">
            <button id="acceptCallBtn" class="call-control-btn call-accept">
                <i class="fas fa-phone"></i>
            </button>
            <button id="rejectCallBtn" class="call-control-btn call-reject">
                <i class="fas fa-phone-slash"></i>
            </button>
        </div>
    </div>

    <!-- DHT Status Indicator -->
    <div class="dht-status">
        <div class="dht-indicator"></div>
        <span id="dht-status-text">Connecting to Backend...</span>
    </div>

    <!-- Forward Message Dialog -->
    <div id="forwardDialog" class="forward-dialog hidden">
        <div class="dialog-backdrop"></div>
        <div class="dialog-content">
            <div class="dialog-header">
                <h3>Forward Message</h3>
                <button id="closeForwardDialog" class="btn-close">✕</button>
            </div>
            <div class="dialog-body">
                <input type="text" id="forwardSearch" placeholder="Search friends..." class="search-input">
                <div id="forwardFriendsList" class="friends-select-list">
                    <!-- Friends will be populated here -->
                </div>
            </div>
            <div class="dialog-footer">
                <button id="cancelForward" class="btn">Cancel</button>
                <button id="confirmForward" class="btn primary">Send</button>
            </div>
        </div>
    </div>

    <!-- Voice Recording Interface -->
    <div id="voiceRecordingUI" class="voice-recording-ui hidden">
        <div class="recording-content">
            <div class="recording-header">
                <i class="fas fa-microphone recording-icon pulsing"></i>
                <span class="recording-text">Recording...</span>
            </div>
            <div class="recording-timer" id="recordingTimer">00:00</div>
            <div class="recording-waveform">
                <div class="wave-bar"></div>
                <div class="wave-bar"></div>
                <div class="wave-bar"></div>
                <div class="wave-bar"></div>
                <div class="wave-bar"></div>
            </div>
            <div class="recording-controls">
                <button id="cancelRecording" class="btn-icon" title="Cancel">
                    <i class="fas fa-trash"></i>
                </button>
                <button id="sendRecording" class="btn-icon primary" title="Send">
                    <i class="fas fa-paper-plane"></i>
                </button>
            </div>
        </div>
    </div>
    <script> // Configuration - Point to your Python backend server
      //  const WS_URL = 'ws://localhost:8766';
       // const API_URL = 'http://localhost:5000/api';
        
    // Frontend configuration through NGINX Load Balancer
        const WS_URL = 'ws://192.168.137.109:8766';     // Direct WebSocket server port
        const API_URL = 'http://192.168.137.109/api';  // HTTP API via NGINX
    // WebSocket via NGINX






        // Global state
        let currentUser = null;
        let currentPeer = null;
        let currentGroup = null;
        let wsConnection = null;
        let peers = [];
        let groups = [];
        let pendingOpenGroupId = null; // set when we want to auto-open a group after join
        let messageHistory = {};
        // IndexedDB helpers for persistent file storage on the local device
        function idbOpen() {
            return new Promise((resolve, reject) => {
                try {
                    const req = indexedDB.open('p2p_files', 1);
                    req.onupgradeneeded = (e) => {
                        const db = e.target.result;
                        if (!db.objectStoreNames.contains('files')) {
                            db.createObjectStore('files', { keyPath: 'id' });
                        }
                    };
                    req.onsuccess = () => resolve(req.result);
                    req.onerror = () => reject(req.error || new Error('IDB open error'));
                } catch (err) { reject(err); }
            });
        }

        function idbPutFile(id, dataUrl, meta = {}) {
            return idbOpen().then(db => new Promise((resolve, reject) => {
                const tx = db.transaction('files', 'readwrite');
                const store = tx.objectStore('files');
                const obj = Object.assign({ id, dataUrl }, meta);
                const r = store.put(obj);
                r.onsuccess = () => resolve(true);
                r.onerror = () => reject(r.error || new Error('IDB put error'));
            }));
        }

        function idbGetFile(id) {
            return idbOpen().then(db => new Promise((resolve, reject) => {
                const tx = db.transaction('files', 'readonly');
                const store = tx.objectStore('files');
                const r = store.get(id);
                r.onsuccess = () => resolve(r.result || null);
                r.onerror = () => reject(r.error || new Error('IDB get error'));
            }));
        }

        function idbDeleteFile(id) {
            return idbOpen().then(db => new Promise((resolve, reject) => {
                const tx = db.transaction('files', 'readwrite');
                const store = tx.objectStore('files');
                const r = store.delete(id);
                r.onsuccess = () => resolve(true);
                r.onerror = () => reject(r.error || new Error('IDB delete error'));
            }));
        }
        let localStream = null;
        let remoteStream = null;
        let peerConnection = null;
        let rtcPeerConnection = null; // RTCPeerConnection instance
        let rtcRemoteStream = null;
        let isInCall = false;
        let isCaller = false;

        // ICE server configuration (fetch from backend; supports TURN)
        let ICE_SERVERS = null;

        async function fetchIceServers() {
            try {
                const res = await fetch(`${API_URL}/ice_servers`);
                if (res.ok) {
                    const data = await res.json();
                    if (data && data.iceServers) {
                        ICE_SERVERS = data.iceServers;
                        console.log('✅ ICE servers loaded from backend', ICE_SERVERS);
                    }
                }
            } catch (e) {
                console.warn('Failed to fetch ICE servers from backend, using default STUN only', e);
            }
        }

        function getIceConfig() {
            return { iceServers: ICE_SERVERS || [{ urls: 'stun:stun.l.google.com:19302' }] };
        }

        // Try to fetch ICE config immediately
        fetchIceServers();

        /// Add these variables to your existing global state section
        let allUsers = []; // All registered users
        let friends = []; // Accepted friends
        let blockedUsers = []; // Blocked users (user_id list)
        let friendRequests = []; // Pending friend requests
        let activeTab = 'all-users';
        // DOM Elements
        const chatPage = document.getElementById('chat-page');
        const emptyView = document.getElementById('empty-view');
        const peerList = document.getElementById('peer-list');
        const chatWith = document.getElementById('chat-with');
        const chatAvatar = document.getElementById('chat-avatar');
        const chatPresence = document.getElementById('chat-presence');
        const chatMessages = document.getElementById('chat-messages');
        const messageInput = document.getElementById('message');
        const sendBtn = document.getElementById('send-btn');
        const dhtStatusText = document.getElementById('dht-status-text');

        // Message formatting toolbar (inserted next to message input)
        function createFormattingToolbar() {
            const toolbar = document.createElement('div');
            toolbar.id = 'format-toolbar';
            toolbar.innerHTML = `
                <button type="button" data-fmt="bold" title="Bold"><b>B</b></button>
                <button type="button" data-fmt="italic" title="Italic"><i>I</i></button>
                <button type="button" data-fmt="underline" title="Underline"><u>U</u></button>
                <button type="button" data-fmt="strike" title="Strikethrough"><s>S</s></button>
                <button type="button" data-fmt="code" title="Inline code"><code>{ }</code></button>
                <button type="button" data-fmt="codeblock" title="Code block">⇲</button>
                <button type="button" data-fmt="spoiler" title="Spoiler">🔒</button>
                <button type="button" data-fmt="link" title="Insert link">🔗</button>
            `;

            toolbar.addEventListener('click', (e) => {
                const btn = e.target.closest('button[data-fmt]');
                if (!btn) return;
                const fmt = btn.getAttribute('data-fmt');
                applyFormatting(fmt);
            });

            // insert toolbar before the input if present, else append to body
            if (messageInput && messageInput.parentNode) {
                messageInput.parentNode.insertBefore(toolbar, messageInput);
            } else {
                document.body.appendChild(toolbar);
            }
        }

        function replaceSelection(el, prefix, suffix, placeholder) {
            el.focus();
            const start = el.selectionStart || 0;
            const end = el.selectionEnd || 0;
            const value = el.value || '';
            const selected = value.slice(start, end) || placeholder || '';
            const newText = prefix + selected + suffix;
            el.value = value.slice(0, start) + newText + value.slice(end);
            // place caret after inserted prefix+selected
            const caret = start + prefix.length + selected.length + suffix.length;
            el.setSelectionRange(caret, caret);
        }

        function applyFormatting(type) {
            if (!messageInput) return;
            switch (type) {
                case 'bold':
                    replaceSelection(messageInput, '<strong>', '</strong>', 'bold');
                    break;
                case 'italic':
                    replaceSelection(messageInput, '<em>', '</em>', 'italic');
                    break;
                case 'underline':
                    replaceSelection(messageInput, '<u>', '</u>', 'underline');
                    break;
                case 'strike':
                    replaceSelection(messageInput, '<s>', '</s>', 'strikethrough');
                    break;
                case 'code':
                    replaceSelection(messageInput, '<code>', '</code>', 'code');
                    break;
                case 'codeblock':
                    replaceSelection(messageInput, '<pre><code>', '</code></pre>', 'code');
                    break;
                case 'spoiler':
                    replaceSelection(messageInput, '<span class="spoiler">', '</span>', 'spoiler');
                    break;
                case 'link': {
                    const selStart = messageInput.selectionStart || 0;
                    const selEnd = messageInput.selectionEnd || 0;
                    const value = messageInput.value || '';
                    const selected = value.slice(selStart, selEnd) || '';
                    const url = prompt('Enter URL (include https://):', 'https://');
                    if (!url) return;
                    const text = selected || prompt('Link text:', url) || url;
                    const html = `<a href="${url}" target="_blank" rel="noopener noreferrer">${text}</a>`;
                    // replace selection or insert at caret
                    messageInput.value = value.slice(0, selStart) + html + value.slice(selEnd);
                    const caretPos = selStart + html.length;
                    messageInput.setSelectionRange(caretPos, caretPos);
                    break;
                }
            }
        }

        // Add minimal styles for toolbar and spoiler
        (function injectFormattingStyles(){
            const css = `
                #format-toolbar { display:flex; gap:6px; margin:6px 0; }
                #format-toolbar button { background:#fff; border:1px solid #ddd; padding:6px 8px; border-radius:6px; cursor:pointer }
                #format-toolbar button:hover { background:#f5f5f5 }
                /* Spoiler: show lock icon and hide text until revealed */
                .spoiler {
                    position: relative;
                    display: inline-block;
                    background: #111;
                    color: transparent;
                    border-radius: 4px;
                    padding: 0 6px;
                    cursor: pointer;
                    overflow: hidden;
                }
                .spoiler::after {
                    content: '🔒';
                    position: absolute;
                    left: 50%;
                    top: 50%;
                    transform: translate(-50%, -50%);
                    color: #fff;
                    font-size: 12px;
                    pointer-events: none;
                }
                .spoiler.revealed {
                    color: inherit;
                    background: transparent;
                }
                .spoiler.revealed::after { content: ''; }
            `;
            const style = document.createElement('style'); style.appendChild(document.createTextNode(css));
            document.head.appendChild(style);
        })();

        // Toggle spoiler visibility when message clicked (delegated)
        document.addEventListener('click', (e) => {
            const sp = e.target.closest('.spoiler');
            if (sp) sp.classList.toggle('revealed');
        });

        // Custom right-click context menu for formatting (input and existing messages)
        (function installContextMenu(){
            const menu = document.createElement('div');
            menu.id = 'custom-format-context';
            menu.style.display = 'none';
            menu.style.position = 'fixed';
            menu.style.zIndex = 2000;
            menu.style.background = '#fff';
            menu.style.border = '1px solid #ccc';
            menu.style.boxShadow = '0 6px 18px rgba(0,0,0,0.12)';
            menu.style.borderRadius = '6px';
            menu.style.padding = '6px';
            menu.innerHTML = `
                <div class="ctx-section">
                    <div class="ctx-item" data-fmt="bold">Bold</div>
                    <div class="ctx-item" data-fmt="italic">Italic</div>
                    <div class="ctx-item" data-fmt="underline">Underline</div>
                    <div class="ctx-item" data-fmt="strike">Strikethrough</div>
                </div>
                <div class="ctx-section" style="margin-top:6px; border-top:1px solid #eee; padding-top:6px;">
                    <div class="ctx-item" data-fmt="code">Inline code</div>
                    <div class="ctx-item" data-fmt="codeblock">Code block</div>
                    <div class="ctx-item" data-fmt="spoiler">Spoiler</div>
                    <div class="ctx-item" data-fmt="link">Insert link</div>
                </div>
            `;

            document.body.appendChild(menu);

            // helper to hide
            function hideMenu() { menu.style.display = 'none'; menu._target = null; }

            // show at coords
            function showMenu(x, y, target) {
                menu.style.left = (x + 2) + 'px';
                menu.style.top = (y + 2) + 'px';
                menu.style.display = 'block';
                menu._target = target || null;
            }

            // apply formatting to either input or message element
            async function applyFmt(fmt, target) {
                if (!target) return;
                if (target === messageInput) {
                    applyFormatting(fmt);
                    return;
                }

                // existing message element — operate on whole message text
                try {
                    const el = target;
                    const original = el.dataset.original_text || el.textContent || el.innerText || '';
                    el.dataset.original_text = original;
                    let wrapped = original;
                    switch(fmt) {
                        case 'bold': wrapped = `<strong>${escapeHtml(original)}</strong>`; break;
                        case 'italic': wrapped = `<em>${escapeHtml(original)}</em>`; break;
                        case 'underline': wrapped = `<u>${escapeHtml(original)}</u>`; break;
                        case 'strike': wrapped = `<s>${escapeHtml(original)}</s>`; break;
                        case 'code': wrapped = `<code>${escapeHtml(original)}</code>`; break;
                        case 'codeblock': wrapped = `<pre><code>${escapeHtml(original)}</code></pre>`; break;
                        case 'spoiler': wrapped = `<span class="spoiler">${escapeHtml(original)}</span>`; break;
                        case 'link': {
                            const url = prompt('URL (include https://):', 'https://');
                            if (!url) return;
                            wrapped = `<a href="${escapeHtml(url)}" target="_blank" rel="noopener noreferrer">${escapeHtml(original)}</a>`;
                            break;
                        }
                        default: wrapped = escapeHtml(original);
                    }
                    el.innerHTML = wrapped;
                } catch (e) {
                    console.warn('Failed to apply formatting to message element', e);
                }
            }

            // Escape helper for safe insertion
            function escapeHtml(s) { return String(s).replace(/[&<>"]+/g, function(m){ return {'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[m]; }); }

            // delegate clicks on menu
            menu.addEventListener('click', (ev) => {
                const it = ev.target.closest('.ctx-item');
                if (!it) return;
                const fmt = it.getAttribute('data-fmt');
                const tgt = menu._target || null;
                applyFmt(fmt, tgt);
                hideMenu();
            });

            // hide on escape or click elsewhere
            document.addEventListener('click', (e) => { if (!e.target.closest('#custom-format-context')) hideMenu(); });
            document.addEventListener('keydown', (e) => { if (e.key === 'Escape') hideMenu(); });

            // attach contextmenu handlers
            if (messageInput) {
                messageInput.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    showMenu(e.clientX, e.clientY, messageInput);
                });
            }

            // messages container: only if right-click on a message element
            if (chatMessages) {
                chatMessages.addEventListener('contextmenu', (e) => {
                    const msg = e.target.closest('.message');
                    if (!msg) return; // allow default if not a message
                    e.preventDefault();
                    showMenu(e.clientX, e.clientY, msg);
                });
            }
        })();

        // create toolbar on DOM ready
        document.addEventListener('DOMContentLoaded', () => createFormattingToolbar());

        // Sidebar search input for contacts
        const sidebarSearchInput = document.getElementById('search');

        // Wire up sidebar search to filter contacts (friends + all users from DB)
        if (sidebarSearchInput) {
            sidebarSearchInput.addEventListener('input', (e) => {
                const q = e.target.value.trim();
                if (!q) {
                    // empty -> restore friends list
                    renderFriendsInSidebar(friends);
                } else {
                    renderContactSearchResults(q);
                }
            });
        }

        // Blocked users persistence
        function loadBlockedUsersFromStorage() {
            try {
                const raw = localStorage.getItem('blocked_users');
                blockedUsers = raw ? JSON.parse(raw) : [];
            } catch (e) { blockedUsers = []; }
        }

        function saveBlockedUsersToStorage() {
            try { localStorage.setItem('blocked_users', JSON.stringify(blockedUsers)); } catch (e) { }
        }

        loadBlockedUsersFromStorage();

        // Call elements
        const callContainer = document.getElementById('callContainer');
        const localVideo = document.getElementById('localVideo');
        const remoteVideo = document.getElementById('remoteVideo');
        const remoteUserLabel = document.getElementById('remoteUserLabel');
        const muteBtn = document.getElementById('muteBtn');
        const videoBtn = document.getElementById('videoBtn');
        const endCallBtn = document.getElementById('endCallBtn');
        const incomingCallAlert = document.getElementById('incomingCallAlert');
        const callerAvatar = document.getElementById('callerAvatar');
        const callerName = document.getElementById('callerName');
        const callType = document.getElementById('callType');
        const acceptCallBtn = document.getElementById('acceptCallBtn');
        const rejectCallBtn = document.getElementById('rejectCallBtn');

        // File elements
        const fileInput = document.getElementById('file-input');
        const fileBtn = document.getElementById('file-btn');
        // FRIEND REQUEST SYSTEM - PRIVATE CHAT FEATURE

        function initializeFriendSystem() {
            loadFriendsFromStorage();
            loadFriendRequestsFromStorage();
            setupFriendEventListeners();
        }

        function setupFriendEventListeners() {
            // Friend tab switching
            document.querySelectorAll('.friend-tab').forEach(tab => {
                tab.addEventListener('click', function () {
                    const tabName = this.dataset.tab;

                    // Update active tab
                    document.querySelectorAll('.friend-tab').forEach(t => t.classList.remove('active'));
                    this.classList.add('active');

                    // Show corresponding content
                    document.querySelectorAll('.friends-tab-content').forEach(content => {
                        content.classList.remove('active');
                    });
                    document.getElementById(`${tabName}-list`).classList.add('active');

                    // Load data for the tab
                    if (tabName === 'discover') {
                        loadDiscoverUsers();
                    }
                });
            });

            // Refresh discover button
            document.getElementById('refresh-discover')?.addEventListener('click', loadDiscoverUsers);
        }

        // FRIEND REQUEST SYSTEM - REQUIRED FOR CHAT
        function loadFriendsFromStorage() {
            try {
                const saved = localStorage.getItem('p2p_friends');
                if (saved) {
                    friends = JSON.parse(saved);
                    renderFriendsList();
                }
            } catch (error) {
                console.warn('Failed to load friends from storage:', error);
                friends = [];
            }
        }


        // Load friend requests from localStorage
        function loadFriendRequestsFromStorage() {
            try {
                const saved = localStorage.getItem('p2p_friend_requests');
                if (saved) {
                    const parsed = JSON.parse(saved);
                    // Support both array and object shapes ({ incoming: [], outgoing: [] })
                    let raw = [];
                    if (Array.isArray(parsed)) {
                        raw = parsed;
                    } else if (parsed && (Array.isArray(parsed.incoming) || Array.isArray(parsed.outgoing))) {
                        raw = [ ...(parsed.incoming || []), ...(parsed.outgoing || []) ];
                    } else if (parsed) {
                        raw = Array.isArray(parsed) ? parsed : [parsed];
                    }

                    // Normalize each request to have canonical keys: sender_id & receiver_id
                    friendRequests = raw.map(r => {
                        const normalized = Object.assign({}, r);
                        if (!normalized.sender_id && normalized.from_id) normalized.sender_id = normalized.from_id;
                        if (!normalized.receiver_id && normalized.to_id) normalized.receiver_id = normalized.to_id;
                        // Some older shapes might use user_id keys, try to map them
                        if (!normalized.sender_id && normalized.user_id) normalized.sender_id = normalized.user_id;
                        if (!normalized.receiver_id && normalized.target_id) normalized.receiver_id = normalized.target_id;
                        return normalized;
                    });

                    renderFriendRequestsList();
                    updateRequestCount();
                }
            } catch (error) {
                console.warn('Failed to load friend requests from storage:', error);
                friendRequests = [];
            }
        }

        // Save friends to localStorage
        function saveFriendsToStorage() {
            try {
                localStorage.setItem('p2p_friends', JSON.stringify(friends));
            } catch (error) {
                console.warn('Failed to save friends to storage:', error);
            }
        }

        // Save friend requests to localStorage
        function saveFriendRequestsToStorage() {
            try {
                localStorage.setItem('p2p_friend_requests', JSON.stringify(friendRequests));
            } catch (error) {
                console.warn('Failed to save friend requests to storage:', error);
            }
        }

        // Compatibility wrappers (some code calls old helper names)
        function saveFriendRequests() {
            try { saveFriendRequestsToStorage(); } catch (e) { console.warn('saveFriendRequests wrapper failed', e); }
        }

        function saveFriends() {
            try { saveFriendsToStorage(); } catch (e) { console.warn('saveFriends wrapper failed', e); }
        }

        function renderFriendRequests() {
            try { renderFriendRequestsList(); } catch (e) { console.warn('renderFriendRequests wrapper failed', e); }
        }

        // Send friend request
        async function sendFriendRequest(toUserId) {
            try {
                if (wsConnection && wsConnection.readyState === WebSocket.OPEN) {
                    const requestData = {
                        type: 'friend_request',
                        from: currentUser.username,
                        from_id: currentUser.id || currentUser.user_id,
                        to_id: toUserId,
                        timestamp: new Date().toISOString()
                    };

                    wsConnection.send(JSON.stringify(requestData));

                    // Update UI immediately
                    friendRequests.push({
                        id: `req_${Date.now()}`,
                        sender_id: currentUser.id || currentUser.user_id,
                        receiver_id: toUserId,
                        status: 'pending',
                        timestamp: new Date().toISOString()
                    });

                    saveFriendRequestsToStorage();
                    renderAllUsers(allUsers);
                    showNotification('Friend request sent', 'success');
                }
            } catch (error) {
                console.error('Error sending friend request:', error);
                showNotification('Failed to send friend request', 'error');
            }
        }


        // Accept friend request
        async function acceptFriendRequest(fromUserId) {
            console.log('acceptFriendRequest called for', fromUserId);
            try {
                if (wsConnection && wsConnection.readyState === WebSocket.OPEN) {
                    const requestData = {
                        type: 'accept_friend_request',
                        from_id: fromUserId,
                        to: currentUser.username,
                        to_id: currentUser.id || currentUser.user_id
                    };

                    console.log('Sending WS accept_friend_request', requestData);
                    wsConnection.send(JSON.stringify(requestData));

                    // Update UI immediately — support multiple request key shapes
                    const findIndex = () => friendRequests.findIndex(r => {
                        const s = String(r.sender_id ?? r.from_id ?? r.from ?? r.user_id ?? '');
                        const t = String(r.receiver_id ?? r.to_id ?? r.to ?? r.target_id ?? '');
                        return s === String(fromUserId) && t === String(currentUser.id || currentUser.user_id);
                    });

                    const requestIndex = findIndex();
                    console.log('acceptFriendRequest: requestIndex=', requestIndex);

                    if (requestIndex !== -1) {
                        friendRequests.splice(requestIndex, 1);

                        const user = allUsers.find(u => String(u.user_id) === String(fromUserId));
                        if (user && !friends.some(f => String(f.user_id) === String(fromUserId))) {
                            friends.push({
                                user_id: user.user_id,
                                username: user.username,
                                avatar: user.avatar,
                                is_online: user.is_online
                            });

                            saveFriendsToStorage();
                            saveFriendRequestsToStorage();

                            renderAllUsers(allUsers);
                            renderFriendsList();
                            updateRequestCount();

                            showNotification('Friend request accepted', 'success');
                        }
                    }
                }
            } catch (error) {
                console.error('Error accepting friend request:', error);
                showNotification('Failed to accept friend request', 'error');
            }
        }

        // Reject friend request
        async function rejectFriendRequest(fromUserId) {
            console.log('rejectFriendRequest called for', fromUserId);
            try {
                if (wsConnection && wsConnection.readyState === WebSocket.OPEN) {
                    const requestData = {
                        type: 'reject_friend_request',
                        from_id: fromUserId,
                        to_id: currentUser.id || currentUser.user_id
                    };

                    console.log('Sending WS reject_friend_request', requestData);
                    wsConnection.send(JSON.stringify(requestData));

                    // Update UI immediately — support multiple request key shapes
                    const findIndex = () => friendRequests.findIndex(r => {
                        const s = String(r.sender_id ?? r.from_id ?? r.from ?? r.user_id ?? '');
                        const t = String(r.receiver_id ?? r.to_id ?? r.to ?? r.target_id ?? '');
                        return s === String(fromUserId) && t === String(currentUser.id || currentUser.user_id);
                    });

                    const requestIndex = findIndex();
                    console.log('rejectFriendRequest: requestIndex=', requestIndex);

                    if (requestIndex !== -1) {
                        friendRequests.splice(requestIndex, 1);
                        saveFriendRequestsToStorage();

                        renderAllUsers(allUsers);
                        updateRequestCount();

                        showNotification('Friend request rejected', 'info');
                    }
                }
            } catch (error) {
                console.error('Error rejecting friend request:', error);
                showNotification('Failed to reject friend request', 'error');
            }
        }

        // Expose to global scope to ensure UI buttons (all-users tab) can call them
        try {
            window.acceptFriendRequest = acceptFriendRequest;
            window.rejectFriendRequest = rejectFriendRequest;
        } catch (e) {
            console.warn('Could not attach friend request handlers to window:', e);
        }

        // Cancel friend request
        async function cancelFriendRequest(toUserId) {
            try {
                if (wsConnection && wsConnection.readyState === WebSocket.OPEN) {
                    const requestData = {
                        type: 'cancel_friend_request',
                        from_id: currentUser.id || currentUser.user_id,
                        to_id: toUserId
                    };

                    wsConnection.send(JSON.stringify(requestData));

                    // Update UI immediately
                    const requestIndex = friendRequests.findIndex(r => {
                        const s = String(r.sender_id ?? r.from_id ?? r.from ?? r.user_id ?? '');
                        const t = String(r.receiver_id ?? r.to_id ?? r.to ?? r.target_id ?? '');
                        return s === String(currentUser.id || currentUser.user_id) && t === String(toUserId);
                    });

                    if (requestIndex !== -1) {
                        friendRequests.splice(requestIndex, 1);
                        saveFriendRequestsToStorage();

                        renderAllUsers(allUsers);
                        showNotification('Friend request cancelled', 'info');
                    }
                }
            } catch (error) {
                console.error('Error cancelling friend request:', error);
                showNotification('Failed to cancel friend request', 'error');
            }
        }

        // Remove friend
        async function removeFriend(friendId) {
            try {
                if (wsConnection && wsConnection.readyState === WebSocket.OPEN) {
                    const requestData = {
                        type: 'remove_friend',
                        user_id: currentUser.id || currentUser.user_id,
                        friend_id: friendId
                    };

                    wsConnection.send(JSON.stringify(requestData));

                    // Update UI immediately
                    const friendIndex = friends.findIndex(f => f.user_id === friendId);
                    if (friendIndex !== -1) {
                        friends.splice(friendIndex, 1);
                        saveFriendsToStorage();

                        renderAllUsers(allUsers);
                        renderFriendsList();

                        showNotification('Friend removed', 'success');
                    }
                }
            } catch (error) {
                console.error('Error removing friend:', error);
                showNotification('Failed to remove friend', 'error');
            }
        }

        // Update your existing WebSocket message handler to include friend request handling
        function updateWebSocketHandler() {
            // In your existing handleRealMessage function, add these cases:
            /*
            case 'friend_request':
                handleIncomingFriendRequest(data);
                break;
            case 'friend_request_accepted':
                handleFriendRequestAccepted(data);
                break;
            case 'friend_request_rejected':
                handleFriendRequestRejected(data);
                break;
            case 'friend_request_cancelled':
                handleFriendRequestCancelled(data);
                break;
            */
        }
        // Render friends list
        function renderFriendsList() {
            const container = document.getElementById('friends-list');
            if (!container) return;

            if (friends.length === 0) {
                container.innerHTML = '<div class="empty-state">No friends yet</div>';
                return;
            }

            container.innerHTML = friends.map(friend => `
        <li class="contact-item" data-user-id="${friend.user_id}">
            <img src="${friend.avatar}" alt="${friend.username}">
            <div class="meta">
                <div class="peer-name">${friend.username}</div>
                <div class="peer-sub">
                    <span class="status-dot ${friend.is_online ? 'online' : 'offline'}"></span>
                    ${friend.is_online ? 'Online' : 'Offline'}
                </div>
            </div>
        </li>
    `).join('');

            // Add click event to start chat
            container.querySelectorAll('.contact-item').forEach(item => {
                item.addEventListener('click', () => {
                    const userId = item.dataset.userId;
                    const friend = friends.find(f => f.user_id === userId);
                    if (friend) {
                        startChatWithFriend(friend);
                    }
                });
            });
        }

        // Start chat with friend
        function startChatWithFriend(friend) {
            if (!friend) return;

            // Set as current peer
            currentPeer = {
                user_id: friend.user_id,
                username: friend.username,
                is_online: friend.is_online
            };

            // Update UI
            chatWith.textContent = friend.username;
            chatPresence.textContent = friend.is_online ? 'Online' : 'Offline';
            chatAvatar.src = friend.avatar || `https://i.pravatar.cc/150?u=${friend.username}`;

            emptyView.classList.add('hidden');
            chatPage.classList.remove('hidden');

            // Ensure group-specific actions are hidden for private/friend chats
            try {
                const addAction = document.getElementById('addMembersAction'); if (addAction) addAction.style.display = 'none';
                const viewAction = document.getElementById('viewGroupInfoAction'); if (viewAction) viewAction.style.display = 'none';
                const groupIndicator = document.getElementById('group-indicator'); if (groupIndicator) groupIndicator.classList.add('hidden');
                // hide the More menu/button for private chats
                const moreBtn = document.getElementById('chatMoreBtn'); if (moreBtn) moreBtn.style.display = 'none';
                const moreMenu = document.getElementById('chatMoreMenu'); if (moreMenu) moreMenu.style.display = 'none';
                currentGroup = null;
            } catch (e) { /* ignore */ }

            loadMessagesForPeer(friend.user_id);
        }

        // Render friend requests list
        function renderFriendRequestsList() {
            const container = document.getElementById('friend-requests-list');
            if (!container) return;

            // Filter incoming requests
            const incomingRequests = friendRequests.filter(r =>
                r.receiver_id === (currentUser?.id || currentUser?.user_id) && r.status === 'pending'
            );

            if (incomingRequests.length === 0) {
                container.innerHTML = '<div class="empty-state">No friend requests</div>';
                return;
            }

            container.innerHTML = incomingRequests.map(request => {
                const sender = allUsers.find(u => u.user_id === request.sender_id);
                if (!sender) return '';

                return `
            <li class="user-item" data-request-id="${request.id}">
                <img src="${sender.avatar}" alt="${sender.username}" class="user-avatar">
                <div class="user-info">
                    <div class="user-name">${sender.username}</div>
                    <div class="user-status">Sent ${formatTimeAgo(request.timestamp)}</div>
                </div>
                <div class="user-actions">
                    <button class="action-btn accept-btn" data-action="accept" data-user-id="${sender.user_id}">
                        <i class="fas fa-check"></i>
                    </button>
                    <button class="action-btn reject-btn" data-action="reject" data-user-id="${sender.user_id}">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
            </li>
        `;
            }).join('');
        }

        // Update request count badge
        function updateRequestCount() {
            const badge = document.getElementById('request-count');
            if (!badge) return;

            const incomingCount = friendRequests.filter(r =>
                r.receiver_id === (currentUser?.id || currentUser?.user_id) && r.status === 'pending'
            ).length;

            if (incomingCount > 0) {
                badge.textContent = incomingCount;
                badge.classList.remove('hidden');
            } else {
                badge.classList.add('hidden');
            }
        }
        // Format time ago
        function formatTimeAgo(timestamp) {
            const date = new Date(timestamp);
            const now = new Date();
            const diffMs = now - date;
            const diffMins = Math.floor(diffMs / 60000);
            const diffHours = Math.floor(diffMs / 3600000);
            const diffDays = Math.floor(diffMs / 86400000);

            if (diffMins < 1) return 'just now';
            if (diffMins < 60) return `${diffMins}m ago`;
            if (diffHours < 24) return `${diffHours}h ago`;
            if (diffDays < 7) return `${diffDays}d ago`;
            return date.toLocaleDateString();
        }
        // View user profile (modal)
        function viewUserProfile(user) {
            // Create modal or update existing modal
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.innerHTML = `
        <div class="modal-content" style="max-width: 400px;">
            <div class="modal-header">
                <div class="modal-title">${user.username}'s Profile</div>
                <button class="close-modal">&times;</button>
            </div>
            <div class="modal-body">
                <div style="text-align: center; margin-bottom: 20px;">
                    <img src="${user.avatar}" alt="${user.username}" 
                         style="width: 100px; height: 100px; border-radius: 50%; object-fit: cover; margin-bottom: 10px;">
                    <h3>${user.username}</h3>
                    <p style="color: ${user.is_online ? 'green' : 'gray'};">
                        <i class="fas fa-circle" style="font-size: 10px;"></i>
                        ${user.is_online ? 'Online' : 'Offline'}
                    </p>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary close-profile-btn">Close</button>
            </div>
        </div>
    `;

            document.body.appendChild(modal);

            // Show modal
            setTimeout(() => modal.style.display = 'flex', 10);

            // Close modal handlers
            modal.querySelector('.close-modal').addEventListener('click', () => {
                modal.style.display = 'none';
                setTimeout(() => modal.remove(), 300);
            });

            modal.querySelector('.close-profile-btn').addEventListener('click', () => {
                modal.style.display = 'none';
                setTimeout(() => modal.remove(), 300);
            });

            // Close on backdrop click
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.style.display = 'none';
                    setTimeout(() => modal.remove(), 300);
                }
            });
        }

        function handleIncomingFriendRequest(data) {
            const request = {
                id: data.request_id || `req_${Date.now()}`,
                from_id: data.from_id ?? data.from ?? data.sender_id,
                from_username: data.from || data.from_username,
                to_id: data.to_id ?? data.to ?? data.receiver_id,
                to_username: data.to || data.to_username,
                timestamp: data.timestamp || new Date().toISOString(),
                status: data.status || 'pending'
            };

            // Normalize canonical keys for runtime checks
            request.sender_id = request.sender_id ?? request.from_id;
            request.receiver_id = request.receiver_id ?? request.to_id;

            // Ensure friendRequests is a flat array and push (avoid duplicates)
            if (!Array.isArray(friendRequests)) friendRequests = [];
            const exists = friendRequests.some(r =>
                String(r.id) === String(request.id) ||
                (String(r.sender_id ?? r.from_id) === String(request.sender_id) && String(r.receiver_id ?? r.to_id) === String(request.receiver_id))
            );
            if (!exists) {
                friendRequests.push(request);
                try { saveFriendRequestsToStorage(); } catch (e) { try { saveFriendRequests(); } catch (_) {} }
            }

            try { renderFriendRequestsList(); } catch (e) { }
            try { updateRequestCount(); } catch (e) { }
            showNotificationWithSound(`New friend request from ${request.from_username || request.sender_id}`, 'info', true);

            // If this client is the intended receiver, ensure All Users tab is visible and highlight the requester
            const myId = String(currentUser?.id || currentUser?.user_id || '');
            if (String(request.receiver_id) === myId) {
                try { if (activeTab !== 'all-users') switchTab('all-users'); } catch (e) { }
                try { renderAllUsers(allUsers); } catch (e) { }
                try {
                    const el = document.querySelector(`#all-users-list .contact-item[data-user-id="${request.sender_id}"]`);
                    if (el) {
                        el.classList.add('highlight-request');
                        el.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        setTimeout(() => el.classList.remove('highlight-request'), 3000);
                    }
                } catch (e) { console.warn('Failed to highlight incoming request user', e); }
            } else {
                try { renderAllUsers(allUsers); } catch (e) { }
            }
        }

        function handleFriendRequestAccepted(data) {
            // Find the corresponding outgoing request (flat array)
            if (!Array.isArray(friendRequests)) friendRequests = [];
            const requestIndex = friendRequests.findIndex(req => String(req.id) === String(data.request_id));
            if (requestIndex !== -1) {
                const request = friendRequests[requestIndex];

                // Determine new friend info (prefer existing allUsers entry)
                const friendUserId = request.receiver_id || request.to_id || data.user_id || data.to_id || data.from_id;
                const userObj = allUsers.find(u => String(u.user_id) === String(friendUserId)) || { user_id: friendUserId, username: request.to_username || data.to || data.from || 'Unknown' };

                const newFriend = {
                    user_id: userObj.user_id,
                    username: userObj.username,
                    is_online: userObj.is_online || true,
                    last_seen: userObj.last_seen || new Date().toISOString(),
                    friendship_date: new Date().toISOString()
                };

                friends.push(newFriend);
                saveFriends();

                // Remove request from flat array
                friendRequests.splice(requestIndex, 1);
                saveFriendRequests();

                // Update UI
                try { renderFriendsList(); } catch (e) { /* best-effort */ }
                renderFriendRequests();

                // Initialize chat history
                try { initializeFriendChatHistory(userObj.user_id); } catch (e) {}

                showNotification(`${userObj.username} accepted your friend request!`, 'success');
            }
        }

        function handleFriendRequestRejected(data) {
            if (!Array.isArray(friendRequests)) friendRequests = [];
            const requestIndex = friendRequests.findIndex(req => String(req.id) === String(data.request_id));
            if (requestIndex !== -1) {
                const req = friendRequests[requestIndex];
                friendRequests.splice(requestIndex, 1);
                saveFriendRequests();
                renderFriendRequests();

                showNotification(`Friend request to ${req.receiver_id || data.to || 'user'} was rejected`, 'info');
            }
        }

        function handleFriendRequestCancelled(data) {
            if (!Array.isArray(friendRequests)) friendRequests = [];
            const requestIndex = friendRequests.findIndex(req => String(req.id) === String(data.request_id));
            if (requestIndex !== -1) {
                const req = friendRequests[requestIndex];
                friendRequests.splice(requestIndex, 1);
                saveFriendRequests();
                renderFriendRequests();

                showNotification(`Friend request from ${req.from_username || data.from} was cancelled`, 'info');
            }
        }

        // Update the sendMessage function to only allow sending to friends
        function updateSendMessage() {
            // In your existing sendMessage function, add this check at the beginning:
            /*
            if (!currentPeer) {
                showNotification('Please select a friend to chat with', 'error');
                return;
            }
            
            // Check if currentPeer is a friend
            const isFriend = friends.some(f => f.user_id === currentPeer.user_id);
            if (!isFriend) {
                showNotification('You can only send messages to friends', 'error');
                return;
            }
            */
        }

        // Initialize friend system when page loads
        document.addEventListener('DOMContentLoaded', function () {
            // Add this to your existing initialization
            initializeFriendSystem();

            // Also update your existing initialization to use friends instead of all peers
            // Replace loadUsersFromAPI() with loadFriendsFromStorage()
        });

        // SIMPLIFIED AUTHENTICATION - More flexible
        function checkAuthentication() {
            console.log('🔐 Checking authentication...');

            const currentUserStr = sessionStorage.getItem('currentUser');
            const isLoggedIn = sessionStorage.getItem('isLoggedIn');

            console.log('  - currentUser exists:', !!currentUserStr);
            console.log('  - isLoggedIn:', isLoggedIn);

            // If we have user data, proceed (even if isLoggedIn is missing or different format)
            if (currentUserStr) {
                try {
                    const userData = JSON.parse(currentUserStr);
                    if (userData && userData.username) {
                        console.log('✅ AUTH SUCCESS: User found -', userData.username);

                        // Ensure isLoggedIn is set for future checks
                        if (!isLoggedIn) {
                            sessionStorage.setItem('isLoggedIn', 'true');
                        }

                        return true;
                    }
                } catch (error) {
                    console.log('❌ Failed to parse user data:', error);
                }
            }

            // If we get here, no valid user data found
            console.log('❌ AUTH FAILED: No valid user data found');
            showNotification('Please login first', 'error');
            // Do not force redirect immediately — allow user to see message and for devs to inspect console.
            // Caller should handle the false return and stop initialization.
            return false;
        }

        // Apply shared avatar image to dashboard UI (profile mini, panel avatar)
        function applySharedAvatarToDashboard(dataUrl) {
            try {
                // panel avatar (img)
                const panelAvatar = document.getElementById('panelAvatar');
                if (panelAvatar && dataUrl) panelAvatar.src = dataUrl;

                // profile mini (may be a div) - try to set image or background
                const profileMini = document.getElementById('profileMini');
                if (profileMini) {
                    if (profileMini.tagName === 'IMG') {
                        profileMini.src = dataUrl;
                    } else {
                        profileMini.innerHTML = `<img src="${dataUrl}" alt="avatar" style="width:100%;height:100%;border-radius:50%;object-fit:cover;">`;
                    }
                }

                // small header/avatar used in the chat header if exists
                const myAvatar = document.getElementById('myAvatar');
                if (myAvatar) {
                    if (myAvatar.tagName === 'IMG') myAvatar.src = dataUrl;
                    else myAvatar.style.backgroundImage = `url(${dataUrl})`;
                }
            } catch (err) {
                console.warn('Failed to apply shared avatar to dashboard:', err);
            }
        }

        // MAIN INITIALIZATION
        document.addEventListener('DOMContentLoaded', function () {
            console.log('🚀 P2P Chat Dashboard initializing...');
            initializeDashboard();
            // Initialize screenshot protection indicator from localStorage
            try {
                const enabled = (localStorage.getItem('screenshot_protection_enabled') || '0') === '1';
                if (enabled) {
                    const banner = document.getElementById('screenshotWarningBanner');
                    if (banner) banner.style.display = 'flex';
                }
            } catch (e) { }
        });

        function initializeDashboard() {
            // Load logged-in user first
            try {
                loadLoggedInUser();
            } catch (err) {
                console.error('Initialization stopped: no logged in user', err);
                setTimeout(() => { window.location.href = 'index.html'; }, 1200);
                return;
            }

            // Load friends and friend requests FIRST
            loadFriendsFromStorage();
            loadFriendRequestsFromStorage();

            // Then initialize the rest
            addEventListeners();
            initializeWebSocket();
            // User list will be requested automatically after WebSocket connects
            try { loadGroupsFromStorage(); } catch (e) { console.warn('Failed to load groups', e); }
            try { initializeGroupModal(); } catch (e) { console.warn('Failed to init group modal', e); }
            try { loadThemeFromLocalStorage(); } catch (err) { console.warn('Error loading theme', err); }

            console.log('✅ Dashboard initialized with', friends.length, 'friends');
        }

        function loadLoggedInUser() {
            const userDataStr = sessionStorage.getItem('currentUser');

            if (!userDataStr) {
                console.error('❌ No user data found in loadLoggedInUser');
                // Don't force redirect; stop initialization gracefully.
                throw new Error('No user session');
            }

            try {
                currentUser = JSON.parse(userDataStr);
                console.log('✅ User loaded from localStorage:', currentUser.username);

                // Ensure all required fields exist with proper fallbacks
                if (!currentUser.user_id) {
                    currentUser.user_id = currentUser.id || 'user_' + Date.now();
                }
                if (!currentUser.profile_data) {
                    currentUser.profile_data = {
                        avatar: `https://i.pravatar.cc/150?u=${currentUser.username}`
                    };
                }
                if (!currentUser.id) {
                    currentUser.id = currentUser.user_id;
                }

                // Fill profile information
                fillUserProfile(currentUser);

            } catch (error) {
                console.error('❌ Failed to parse user data:', error);
                showNotification('Session expired. Please login again.', 'error');
                // Stop initialization; caller will handle redirection if needed.
                throw error;
            }
        }

        function fillUserProfile(user) {
            console.log('🎯 Filling profile for:', user.username);

            const elementsToUpdate = {
                'profile-name': user.username,
                'panelName': user.username,
                // Prefer avatar saved in localStorage (set from profile.html) over generated avatar
                'profile-avatar': localStorage.getItem('p2p_profile_avatar') || user.profile_data?.avatar || 'https://i.pravatar.cc/150?u=' + user.username,
                'panelAvatar': localStorage.getItem('p2p_profile_avatar') || user.profile_data?.avatar || 'https://i.pravatar.cc/150?u=' + user.username,
                'panelUserID': user.id || user.user_id,
                'panelNodeID': user.node_id || 'node_' + (user.id || user.user_id),
                'panelDID': user.did || 'did:p2p:' + (user.id || user.user_id)
            };

            for (const [elementId, value] of Object.entries(elementsToUpdate)) {
                const element = document.getElementById(elementId);
                if (element) {
                    if (elementId.includes('avatar')) {
                        element.src = value;
                    } else {
                        element.textContent = value;
                    }
                }
            }
        }

        // Profile update listener for tp.html
        function initializeProfileSync() {
            // Load initial profile data
            loadProfileData();
            // Load profile picture/avatar if available
            loadProfilePicture();

            // Listen for storage events (updates from other tabs)
            window.addEventListener('storage', function (e) {
                if (e.key === 'userProfile' || e.key === 'profileUpdated') {
                    loadProfileData();
                }
                if (e.key === 'userProfilePicture' || e.key === 'profilePictureUpdated' || e.key === 'p2p_profile_avatar') {
                    loadProfilePicture();
                }
            });

            // Also listen for same-tab updates
            window.addEventListener('profileUpdated', function () {
                loadProfileData();
            });
        }

        // Function to load profile data in dashboard
        function loadProfileData() {
            const profileData = localStorage.getItem('userProfile');
            if (profileData) {
                const profile = JSON.parse(profileData);

                // Update profile elements in tp.html
                const profileNameElement = document.querySelector('.profile-name, [data-profile="name"]');
                const profileStatusElement = document.querySelector('.profile-status, [data-profile="status"]');

                if (profileNameElement) {
                    profileNameElement.textContent = profile.name;
                }

                if (profileStatusElement) {
                    profileStatusElement.textContent = profile.status;
                }

                // Update any other profile-related elements
                updateDashboardProfile(profile);
            }
        }

        // Function to load profile picture in dashboard
        function loadProfilePicture() {
            // Support both legacy key and the app-wide avatar key used by profile.html
            const profilePicture = localStorage.getItem('userProfilePicture') || localStorage.getItem('p2p_profile_avatar');
            if (profilePicture) {
                const profilePicElement = document.querySelector('.profile-pic, [data-profile="picture"]');
                if (profilePicElement) {
                    profilePicElement.innerHTML = `<img src="${profilePicture}" alt="Profile Picture" style="width:100%;height:100%;border-radius:50%;object-fit:cover;">`;
                }
                // Apply to dashboard-specific avatar slots
                applySharedAvatarToDashboard(profilePicture);
            }
        }

        // Function to update dashboard-specific profile elements
        function updateDashboardProfile(profile) {
            // Add any dashboard-specific profile updates here
            // For example, update chat headers, user info panels, etc.

            // Example: Update user info in chat headers
            const chatHeaders = document.querySelectorAll('.chat-header .user-name');
            chatHeaders.forEach(header => {
                header.textContent = profile.name;
            });

            // Example: Update status in user info panels
            const statusIndicators = document.querySelectorAll('.status-indicator');
            statusIndicators.forEach(indicator => {
                indicator.textContent = profile.status;
                indicator.className = `status-indicator ${profile.status.toLowerCase()}`;
            });
        }

        // Initialize profile sync when page loads
        document.addEventListener('DOMContentLoaded', function () {
            initializeProfileSync();
        });

        // Load and apply theme from localStorage (applies site-wide visual theme)
        function loadThemeFromLocalStorage() {
            try {
                const savedTheme = localStorage.getItem('app_theme');
                const wallpaperColor = localStorage.getItem('wallpaper_color');
                const homeBg = localStorage.getItem('home_bg_color');
                const chatWallpaper = localStorage.getItem('chat_wallpaper');
                if (savedTheme) {
                    // apply theme (applyTheme may be defined below)
                    if (typeof applyTheme === 'function') applyTheme(savedTheme);
                }
                // apply home background color if provided (keeps index color consistent across app)
                if (homeBg) {
                    try { document.body.style.backgroundColor = homeBg; document.documentElement.style.setProperty('--home-bg', homeBg); } catch (e) { }
                }
                if (wallpaperColor) {
                    // apply a lightweight wallpaper color to body/container if available
                    document.body.style.backgroundColor = wallpaperColor;
                    // set panel border to a translucent version of wallpaper color so panels blend
                    try {
                        // convert hex #rrggbb to rgba with 0.12 alpha if possible
                        const hex = wallpaperColor.trim();
                        if (/^#([0-9A-F]{3}){1,2}$/i.test(hex)) {
                            const c = hex.substring(1);
                            const bigint = parseInt(c.length === 3 ? c.split('').map(ch => ch + ch).join('') : c, 16);
                            const r = (bigint >> 16) & 255;
                            const g = (bigint >> 8) & 255;
                            const b = bigint & 255;
                            document.documentElement.style.setProperty('--panel-border', `rgba(${r},${g},${b},0.12)`);
                            // panel background slightly translucent over wallpaper
                            document.documentElement.style.setProperty('--panel-bg', `rgba(${255},255,255,0.82)`);
                        }
                    } catch (e) { /* ignore */ }
                }
                // (Optional) apply chat wallpaper via a CSS variable or class
                if (chatWallpaper) {
                    document.documentElement.style.setProperty('--chat-wallpaper', `url(${chatWallpaper})`);
                    // also apply to main app container if present
                    const appEl = document.getElementById('app');
                    if (appEl) {
                        // prefer using backgroundImage for immediate effect
                        try { appEl.style.backgroundImage = `url(${chatWallpaper})`; appEl.style.backgroundSize = 'cover'; } catch (e) { }
                    }
                }
            } catch (err) {
                console.warn('Failed to apply theme from localStorage', err);
            }
        }

        // Apply theme across the dashboard; mirrors logic in other pages
        function applyTheme(theme) {
            const body = document.body;
            const appEl = document.getElementById('app');
            body.classList.remove('light-theme', 'dark-theme', 'coffee-theme');
            if (appEl) appEl.classList.remove('light-theme', 'dark-theme', 'coffee-theme');

            if (theme === 'dark') {
                body.classList.add('dark-theme');
                body.style.background = '#1e1e1e';
                body.style.color = '#fff';
                if (appEl) { appEl.style.background = '#2d2d2d'; }
            } else if (theme === 'coffee') {
                body.classList.add('coffee-theme');
                body.style.background = '#6f4e37';
                body.style.color = '#f5f5f5';
                if (appEl) { appEl.style.background = '#8b6b4f'; }
            } else {
                body.classList.add('light-theme');
                body.style.background = '';
                body.style.backgroundColor = '';
                body.style.color = '';
                if (appEl) { appEl.style.background = ''; }
            }

            // Ensure wallpaper color overrides general background where applicable
            const wallpaperColor = localStorage.getItem('wallpaper_color');
            if (wallpaperColor) {
                try { body.style.backgroundColor = wallpaperColor; } catch (e) { }
            }
        }

        // Listen for theme updates from settings page (other tabs)
        window.addEventListener('storage', function (e) {
            if (!e) return;
            if (e.key === 'themeUpdated' || e.key === 'app_theme' || e.key === 'wallpaper_color' || e.key === 'home_bg_color') {
                loadThemeFromLocalStorage();
            }
        });

        // Also apply theme when the page gains focus or becomes visible (handles same-tab navigation)
        window.addEventListener('focus', () => {
            try { loadThemeFromLocalStorage(); } catch (err) { /* ignore */ }
        });
        document.addEventListener('visibilitychange', () => {
            if (document.visibilityState === 'visible') {
                try { loadThemeFromLocalStorage(); } catch (err) { /* ignore */ }
            }
        });

        // WEB SOCKET FUNCTIONS - COMPATIBLE WITH YOUR FLASK BACKEND
        function initializeWebSocket() {
            console.log('🔌 Initializing WebSocket connection to backend...');

            try {
                wsConnection = new WebSocket(WS_URL);

                wsConnection.onopen = () => {
                    console.log('✅ WebSocket Connected to backend server:', WS_URL);
                    showNotification('Connected to P2P Chat network', 'success');
                    dhtStatusText.textContent = 'Connected to Backend';

                    if (currentUser) {
                        // Send registration message in the format your Flask backend expects
                        const registerMsg = {
                            type: 'register',
                            username: currentUser.username,
                            user_id: currentUser.id || currentUser.user_id,
                            profile_data: currentUser.profile_data
                        };
                        wsConnection.send(JSON.stringify(registerMsg));

                        // Request friend request data from backend
                        setTimeout(() => {
                            if (wsConnection && wsConnection.readyState === WebSocket.OPEN) {
                                console.log('📡 Requesting user data from backend...');

                                // Request all users with friend status
                                wsConnection.send(JSON.stringify({ type: 'get_users' }));

                                // Request friend requests (incoming and outgoing)
                                wsConnection.send(JSON.stringify({ type: 'get_friend_requests' }));

                                // Request friends list
                                wsConnection.send(JSON.stringify({ type: 'get_friends' }));

                                // Request groups list
                                wsConnection.send(JSON.stringify({ type: 'get_groups' }));

                                console.log('✅ Friend request data requested from backend');
                            }
                        }, 500); // Small delay to ensure registration is processed first

                        // Flush queued outgoing messages/files saved locally
                        try {
                            flushQueuedMessages();
                        } catch (err) {
                            console.warn('Failed to flush queued messages on reconnect:', err);
                        }
                    }
                };

                wsConnection.onmessage = (event) => {
                    console.log('📥 Received WebSocket message from backend:', event.data);
                    try {
                        const data = JSON.parse(event.data);
                        handleRealMessage(data);
                    } catch (error) {
                        console.error('❌ Failed to parse WebSocket message:', error);
                    }
                };

                wsConnection.onclose = (event) => {
                    console.log('❌ WebSocket disconnected from backend:', event.code, event.reason);
                    showNotification('Disconnected from server - reconnecting...', 'error');
                    dhtStatusText.textContent = 'Reconnecting...';
                    setTimeout(() => initializeWebSocket(), 3000);
                };

                wsConnection.onerror = (error) => {
                    console.error('🔌 WebSocket connection error:', error);
                    showNotification('Connection error with backend server', 'error');
                    dhtStatusText.textContent = 'Connection Error';
                };

            } catch (error) {
                console.error('❌ WebSocket connection failed:', error);
                showNotification('Failed to connect to backend server', 'error');
                dhtStatusText.textContent = 'Failed to Connect';
            }
        }

        // CALL FUNCTIONALITY
        async function startVideoCall() {
            if (!currentPeer) {
                showNotification('Please select a contact to call', 'error');
                return;
            }

            try {
                showNotification('Starting video call...', 'info');
                localStream = await navigator.mediaDevices.getUserMedia({
                    video: true,
                    audio: true
                });

                localVideo.srcObject = localStream;
                isCaller = true;
                isInCall = true;

                // Show call interface
                callContainer.classList.add('active');
                remoteUserLabel.textContent = currentPeer.username;

                // Send call request via WebSocket
                const callData = {
                    type: 'call_request',
                    call_type: 'video',
                    from: currentUser.username,
                    from_id: currentUser.id,
                    to: currentPeer.username,
                    to_id: currentPeer.user_id
                };

                if (wsConnection && wsConnection.readyState === WebSocket.OPEN) {
                    wsConnection.send(JSON.stringify(callData));
                }

            } catch (error) {
                console.error('Error starting video call:', error);
                // Provide more detailed feedback to user and recommend checks
                const msg = (error && error.message) ? error.message : String(error);
                showNotification(`Failed to access camera/microphone: ${msg}`, 'error');
                console.warn('Check browser permissions, secure context (https) or use http://localhost', error);
            }
        }

        async function startAudioCall() {
            if (!currentPeer) {
                showNotification('Please select a contact to call', 'error');
                return;
            }

            try {
                showNotification('Starting audio call...', 'info');
                localStream = await navigator.mediaDevices.getUserMedia({
                    video: false,
                    audio: true
                });

                localVideo.srcObject = localStream;
                isCaller = true;
                isInCall = true;

                // Show call interface
                callContainer.classList.add('active');
                remoteUserLabel.textContent = currentPeer.username;

                // Send call request via WebSocket
                const callData = {
                    type: 'call_request',
                    call_type: 'audio',
                    from: currentUser.username,
                    from_id: currentUser.id,
                    to: currentPeer.username,
                    to_id: currentPeer.user_id
                };

                if (wsConnection && wsConnection.readyState === WebSocket.OPEN) {
                    wsConnection.send(JSON.stringify(callData));
                }

            } catch (error) {
                console.error('Error starting audio call:', error);
                const msg = (error && error.message) ? error.message : String(error);
                showNotification(`Failed to access microphone: ${msg}`, 'error');
                console.warn('Check browser permissions and secure context (https) or use http://localhost', error);
            }
        }

        function endCall() {
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
            }

            if (remoteStream) {
                remoteStream.getTracks().forEach(track => track.stop());
                remoteStream = null;
            }

            localVideo.srcObject = null;
            remoteVideo.srcObject = null;

            callContainer.classList.remove('active');
            incomingCallAlert.classList.remove('active');
            isInCall = false;
            isCaller = false;

            // Cleanup RTC connection
            try {
                if (rtcPeerConnection) {
                    rtcPeerConnection.close();
                    rtcPeerConnection = null;
                }
                rtcRemoteStream = null;
            } catch (e) { }

            // Send call end notification
            if (currentPeer && wsConnection && wsConnection.readyState === WebSocket.OPEN) {
                const callData = {
                    type: 'call_end',
                    from: currentUser.username,
                    from_id: currentUser.id,
                    to: currentPeer.username,
                    to_id: currentPeer.user_id
                };
                wsConnection.send(JSON.stringify(callData));
            }

            showNotification('Call ended', 'info');
        }

        function toggleMute() {
            if (localStream) {
                const audioTracks = localStream.getAudioTracks();
                audioTracks.forEach(track => {
                    track.enabled = !track.enabled;
                });
                muteBtn.innerHTML = audioTracks[0].enabled ?
                    '<i class="fas fa-microphone"></i>' :
                    '<i class="fas fa-microphone-slash"></i>';
            }
        }

        function toggleVideo() {
            if (localStream) {
                const videoTracks = localStream.getVideoTracks();
                videoTracks.forEach(track => {
                    track.enabled = !track.enabled;
                });
                videoBtn.innerHTML = videoTracks[0].enabled ?
                    '<i class="fas fa-video"></i>' :
                    '<i class="fas fa-video-slash"></i>';
            }
        }

        // Create and configure RTCPeerConnection for WebRTC calls
        function createPeerConnection(remoteUsername) {
            try {
                const pc = new RTCPeerConnection(getIceConfig());

                // Remote stream container
                rtcRemoteStream = new MediaStream();
                remoteVideo.srcObject = rtcRemoteStream;

                pc.ontrack = (event) => {
                    try {
                        event.streams.forEach(s => {
                            rtcRemoteStream = s;
                            remoteVideo.srcObject = s;
                        });
                    } catch (e) { console.warn('ontrack error', e); }
                };

                pc.onicecandidate = (ev) => {
                    if (ev.candidate && wsConnection && wsConnection.readyState === WebSocket.OPEN) {
                        wsConnection.send(JSON.stringify({
                            type: 'webrtc_ice_candidate',
                            to: remoteUsername,
                            candidate: ev.candidate
                        }));
                    }
                };

                pc.onconnectionstatechange = () => {
                    console.log('RTC connection state:', pc.connectionState);
                    if (pc.connectionState === 'disconnected' || pc.connectionState === 'failed' || pc.connectionState === 'closed') {
                        // cleanup
                    }
                };

                return pc;
            } catch (err) {
                console.error('createPeerConnection failed', err);
                return null;
            }
        }

        // Handle incoming WebRTC signaling messages
        async function handleWebrtcOffer(data) {
            try {
                const from = data.from;
                const offer = data.offer;
                if (!rtcPeerConnection) {
                    rtcPeerConnection = createPeerConnection(from);
                    if (localStream) localStream.getTracks().forEach(t => rtcPeerConnection.addTrack(t, localStream));
                }
                await rtcPeerConnection.setRemoteDescription(new RTCSessionDescription(offer));
                const answer = await rtcPeerConnection.createAnswer();
                await rtcPeerConnection.setLocalDescription(answer);
                if (wsConnection && wsConnection.readyState === WebSocket.OPEN) {
                    wsConnection.send(JSON.stringify({ type: 'webrtc_answer', to: from, answer: answer }));
                }
            } catch (err) { console.error('handleWebrtcOffer error', err); }
        }

        async function handleWebrtcAnswer(data) {
            try {
                const answer = data.answer;
                if (rtcPeerConnection && answer) {
                    await rtcPeerConnection.setRemoteDescription(new RTCSessionDescription(answer));
                }
            } catch (err) { console.error('handleWebrtcAnswer error', err); }
        }

        function handleWebrtcIceCandidate(data) {
            try {
                const candidate = data.candidate;
                if (rtcPeerConnection && candidate) {
                    rtcPeerConnection.addIceCandidate(new RTCIceCandidate(candidate)).catch(e => console.warn('addIceCandidate failed', e));
                }
            } catch (err) { console.error('handleWebrtcIceCandidate error', err); }
        }

        // FILE SHARING FUNCTIONALITY
        function handleFileSelect(event) {
            const files = event.target.files;
            if (!files.length) return;

            Array.from(files).forEach(file => {
                if (file.size > 50 * 1024 * 1024) { // 50MB limit
                    showNotification('File too large. Maximum size is 50MB', 'error');
                    return;
                }

                // Create file message
                const fileMessage = {
                    id: 'file_' + Date.now(),
                    type: 'file',
                    file_name: file.name,
                    file_size: formatFileSize(file.size),
                    file_type: file.type,
                    timestamp: new Date().toISOString(),
                    is_outgoing: true,
                    sender_id: currentUser.id || currentUser.user_id,
                    sender_username: currentUser.username,
                    sent: false,
                    seen: false,
                    deleted_request: false
                };

                // Store in history
                if (currentPeer) {
                    storeMessageInHistory(fileMessage, currentPeer.user_id);
                }

                // Add to UI (message appears immediately)
                addFileMessageToUI(fileMessage, true);

                // Read file content and attach as data URL so downloads work locally and send to peer
                const reader = new FileReader();
                reader.onload = function (e) {
                    try {
                        const dataUrl = e.target.result; // data:<mime>;base64,...

                        // Persist raw file bytes into IndexedDB for permanent local storage
                        try {
                            idbPutFile(fileMessage.id, dataUrl, { file_name: file.name, file_type: file.type, file_size: file.size, timestamp: fileMessage.timestamp })
                                .catch(err => console.warn('Failed to save file to IndexedDB', err));
                            // store reference to file id so message metadata can be persisted
                            fileMessage.file_id = fileMessage.id;
                            // do NOT store large base64 in localStorage; persist only metadata
                            if (currentPeer) {
                                try {
                                    const list = messageHistory[currentPeer.user_id] || [];
                                    const metaMsg = Object.assign({}, fileMessage);
                                    delete metaMsg.file_data;
                                    // Replace optimistic entry if present
                                    const idx = list.findIndex(m => m.id === metaMsg.id);
                                    if (idx !== -1) list[idx] = metaMsg; else list.push(metaMsg);
                                    messageHistory[currentPeer.user_id] = list;
                                    try { localStorage.setItem(`msg_history_${currentPeer.user_id}`, JSON.stringify(list)); } catch (err) { /* ignore */ }
                                } catch (err) { console.warn('Failed to persist file message metadata', err); }
                            }

                        } catch (err) { console.warn('Failed to attach file data', err); }

                        // Send file via WebSocket including data URL so recipient can download it (server-side persistence optional)
                        try {
                            if (wsConnection && wsConnection.readyState === WebSocket.OPEN) {
                                const fileData = {
                                    type: 'file_message',
                                    from: currentUser.username,
                                    from_id: currentUser.id || currentUser.user_id,
                                    to: currentPeer.username,
                                    to_id: currentPeer.user_id,
                                    file_name: file.name,
                                    file_size: file.size,
                                    file_type: file.type,
                                    timestamp: new Date().toISOString(),
                                    file_data: dataUrl,
                                    client_id: fileMessage.id
                                };
                                wsConnection.send(JSON.stringify(fileData));
                            } else {
                                showNotification('Offline: file queued locally; will send when reconnected', 'info');
                            }
                        } catch (sendErr) {
                            console.error('File send failed:', sendErr);
                            showNotification('File queued locally; will send when reconnected', 'error');
                        }

                        // Simulate file upload progress
                        simulateFileUpload(file);

                    } catch (err) { console.warn('Failed to attach file data', err); }
                };
                reader.readAsDataURL(file);
            });

            // Reset file input
            event.target.value = '';
        }

        function simulateFileUpload(file) {
            showNotification(`Uploading ${file.name}...`, 'info');
            setTimeout(() => {
                showNotification(`${file.name} uploaded successfully`, 'success');
            }, 2000);
        }

        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        function addFileMessageToUI(fileData, isOutgoing = false) {
            const messageEl = document.createElement('div');
            messageEl.className = `message ${isOutgoing ? 'outgoing' : 'incoming'}`;

            const fileIcon = getFileIcon(fileData.file_type);

            messageEl.innerHTML = `
        ${!isOutgoing ? `<div class="message-sender">${fileData.sender_username || 'Unknown'}</div>` : ''}
        <div class="file-preview">
            <div class="file-info">
                <div class="file-icon">${fileIcon}</div>
                <div class="file-details">
                    <div class="file-name">${fileData.file_name}</div>
                    <div class="file-size">${fileData.file_size}</div>
                </div>
                <button class="download-btn" onclick="downloadFile('${fileData.id}')" data-file-id="${fileData.id}">
                    <i class="fas fa-download"></i>
                </button>
            </div>
        </div>
        <div class="message-time">${new Date(fileData.timestamp).toLocaleTimeString()}</div>
    `;

            // Attach message id for later lookup
            if (fileData.id) messageEl.dataset.msgId = fileData.id;

            // Determine conversation target id for this file message
            const convTargetId = isOutgoing ? (fileData.receiver_id || currentPeer?.user_id) : (fileData.sender_id || currentPeer?.user_id);

            // Add delete-for-me and delete-for-everyone actions
            const actions = document.createElement('div');
            actions.className = 'msg-actions';
            const delMe = document.createElement('button');
            delMe.className = 'msg-delete-me btn-small';
            delMe.textContent = 'Delete for me';
            delMe.addEventListener('click', () => deleteLocalMessage(messageEl.dataset.msgId, convTargetId));
            actions.appendChild(delMe);
            if (isOutgoing) {
                const delAll = document.createElement('button');
                delAll.className = 'msg-delete btn-small';
                delAll.textContent = 'Delete for everyone';
                delAll.addEventListener('click', () => deleteMessageForEveryone(messageEl.dataset.msgId, convTargetId));
                actions.appendChild(delAll);
            }
            messageEl.appendChild(actions);

            // status for outgoing messages (delivered/seen)
            if (isOutgoing) {
                const status = document.createElement('span');
                status.className = 'msg-status pending';
                status.title = 'Pending';
                messageEl.appendChild(status);
            }

            chatMessages.appendChild(messageEl);
            scrollToBottom();
        }

        // Flush locally queued outgoing messages/files when WS reconnects
        function flushQueuedMessages() {
            if (!wsConnection || wsConnection.readyState !== WebSocket.OPEN) return;

            Object.keys(messageHistory).forEach(targetId => {
                const list = messageHistory[targetId];
                if (!Array.isArray(list)) return;

                list.forEach(msg => {
                    // Only attempt to send outgoing messages that are not marked sent
                    if (msg.is_outgoing && !msg.sent && !msg.deleted_request) {
                        let payload = null;
                        if (msg.type === 'file') {
                            payload = {
                                type: 'file_message',
                                from: msg.sender_username || (currentUser && currentUser.username),
                                from_id: msg.sender_id || (currentUser && (currentUser.id || currentUser.user_id)),
                                to: peers.find(p => String(p.user_id) === String(targetId))?.username || undefined,
                                to_id: targetId,
                                client_id: msg.id,
                                file_name: msg.file_name,
                                file_size: msg.file_size,
                                file_type: msg.file_type || 'application/octet-stream',
                                timestamp: msg.timestamp
                            };
                        } else {
                            payload = {
                                type: 'send_message',
                                from: msg.sender_username || (currentUser && currentUser.username),
                                from_id: msg.sender_id || (currentUser && (currentUser.id || currentUser.user_id)),
                                to: peers.find(p => String(p.user_id) === String(targetId))?.username || undefined,
                                to_id: targetId,
                                client_id: msg.id,
                                message: msg.message,
                                timestamp: msg.timestamp
                            };
                        }

                        try {
                            wsConnection.send(JSON.stringify(payload));
                            // mark as sent locally
                            msg.sent = true;
                            // persist updated history
                            try { localStorage.setItem(`msg_history_${targetId}`, JSON.stringify(list)); } catch (e) { }
                        } catch (err) {
                            console.warn('Failed to send queued msg', err);
                        }
                    }
                });
            });
        }

        function getFileIcon(fileType) {
            if (fileType.startsWith('image/')) return '<i class="fas fa-file-image"></i>';
            if (fileType.startsWith('video/')) return '<i class="fas fa-file-video"></i>';
            if (fileType.startsWith('audio/')) return '<i class="fas fa-file-audio"></i>';
            if (fileType.includes('pdf')) return '<i class="fas fa-file-pdf"></i>';
            if (fileType.includes('word') || fileType.includes('document')) return '<i class="fas fa-file-word"></i>';
            if (fileType.includes('excel') || fileType.includes('spreadsheet')) return '<i class="fas fa-file-excel"></i>';
            if (fileType.includes('zip') || fileType.includes('archive')) return '<i class="fas fa-file-archive"></i>';
            return '<i class="fas fa-file"></i>';
        }

                async function downloadFile(idOrFilename) {
                    showNotification(`Downloading ${idOrFilename}...`, 'info');

                    // Try to find the file message by id first, then by filename
                    let found = null;
                    try {
                        Object.keys(messageHistory || {}).forEach(targetId => {
                            const list = messageHistory[targetId] || [];
                            list.forEach(m => {
                                if (!found && (m.id === idOrFilename || m.file_name === idOrFilename)) found = m;
                            });
                        });
                    } catch (err) { /* ignore */ }

                    if (!found) {
                        // No stored file data found — fallback to simulated content
                        const blob = new Blob(['This is a simulated file download for: ' + idOrFilename], { type: 'text/plain' });
                        triggerBrowserDownload(blob, idOrFilename);
                        return;
                    }

                    // Try to load raw bytes from persisted storage (IndexedDB) if not present inline
                    const tryId = found.file_id || found.id;
                    if ((!found.file_data || typeof found.file_data !== 'string') && tryId) {
                        try {
                            const rec = await idbGetFile(tryId);
                            if (rec && rec.dataUrl) {
                                fetch(rec.dataUrl).then(res => res.blob()).then(blob => {
                                    triggerBrowserDownload(blob, found.file_name || idOrFilename);
                                }).catch(err => {
                                    console.warn('Failed to fetch IDB dataUrl', err);
                                    const blob = new Blob(['File data unavailable'], { type: 'text/plain' });
                                    triggerBrowserDownload(blob, found.file_name || idOrFilename);
                                });
                                return;
                            }
                        } catch (e) { console.warn('IDB read failed', e); }
                    }

                    // If the message contains an embedded data URL (from FileReader), use it
                    if (found.file_data && typeof found.file_data === 'string' && found.file_data.startsWith('data:')) {
                        // Convert data URL to blob via fetch
                        fetch(found.file_data).then(res => res.blob()).then(blob => {
                            triggerBrowserDownload(blob, found.file_name || idOrFilename);
                        }).catch(err => {
                            console.warn('Failed to fetch data URL', err);
                            const blob = new Blob(['File data unavailable'], { type: 'text/plain' });
                            triggerBrowserDownload(blob, found.file_name || idOrFilename);
                        });
                        return;
                    }

                    // If file_data is an ArrayBuffer or raw data (unlikely here), create blob
                    if (found.file_data && (found.file_data instanceof ArrayBuffer || found.file_data instanceof Uint8Array)) {
                        const blob = new Blob([found.file_data], { type: found.file_type || 'application/octet-stream' });
                        triggerBrowserDownload(blob, found.file_name || idOrFilename);
                        return;
                    }

                    // Nothing usable — fallback
                    const blob = new Blob(['File data not present on this client.'], { type: 'text/plain' });
                    triggerBrowserDownload(blob, found.file_name || idOrFilename);
                }

                function triggerBrowserDownload(blob, filename) {
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = filename || 'download.bin';
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    setTimeout(() => URL.revokeObjectURL(url), 5000);
                }

        // MESSAGE FORWARDING FUNCTIONALITY
        let currentForwardMessage = null;

        function openForwardDialog(messageData) {
            currentForwardMessage = messageData;
            const dialog = document.getElementById('forwardDialog');
            const friendsList = document.getElementById('forwardFriendsList');
            const searchInput = document.getElementById('forwardSearch');

            // Clear previous selections
            friendsList.innerHTML = '';
            searchInput.value = '';

            // Populate friends list
            if (friends.length === 0) {
                friendsList.innerHTML = '<div style="text-align:center; padding:20px; color:#999;">No friends to forward to</div>';
            } else {
                renderForwardFriendsList(friends);
            }

            // Show dialog
            dialog.classList.remove('hidden');
        }

        function renderForwardFriendsList(friendsToShow) {
            const friendsList = document.getElementById('forwardFriendsList');
            friendsList.innerHTML = '';

            friendsToShow.forEach(friend => {
                const item = document.createElement('div');
                item.className = 'friend-select-item';
                item.innerHTML = `
                    <input type="checkbox" id="forward-${friend.user_id}" value="${friend.user_id}">
                    <img src="https://i.pravatar.cc/150?u=${friend.username}" alt="${friend.username}">
                    <div class="name">${friend.username}</div>
                `;

                // Click anywhere on item to toggle checkbox
                item.addEventListener('click', (e) => {
                    if (e.target.tagName !== 'INPUT') {
                        const checkbox = item.querySelector('input[type="checkbox"]');
                        checkbox.checked = !checkbox.checked;
                    }
                });

                friendsList.appendChild(item);
            });
        }

        function closeForwardDialog() {
            const dialog = document.getElementById('forwardDialog');
            dialog.classList.add('hidden');
            currentForwardMessage = null;
        }

        function forwardMessageToSelected() {
            if (!currentForwardMessage) return;

            // Get selected friends
            const checkboxes = document.querySelectorAll('#forwardFriendsList input[type="checkbox"]:checked');
            const selectedFriendIds = Array.from(checkboxes).map(cb => cb.value);

            if (selectedFriendIds.length === 0) {
                showNotification('Please select at least one friend', 'error');
                return;
            }

            // Get message text
            const messageText = currentForwardMessage.message || '';

            // Send to each selected friend
            selectedFriendIds.forEach(friendId => {
                const friend = friends.find(f => String(f.user_id) === String(friendId));
                if (!friend) return;

                // Create forwarded message
                const forwardedMessage = {
                    type: 'send_message',
                    from: currentUser.username,
                    from_id: currentUser.id || currentUser.user_id,
                    to: friend.username,
                    to_id: friend.user_id,
                    message: messageText,  // Send original message without prefix
                    is_forwarded: true,    // Mark as forwarded
                    client_id: 'temp_' + Date.now() + '_' + friendId,
                    timestamp: new Date().toISOString()
                };

                // Store in local history
                const localMsg = {
                    id: forwardedMessage.client_id,
                    sender_id: currentUser.id || currentUser.user_id,
                    sender_username: currentUser.username,
                    receiver_id: friend.user_id,
                    message: messageText,  // Store original message
                    is_forwarded: true,    // Mark as forwarded
                    timestamp: forwardedMessage.timestamp,
                    is_outgoing: true,
                    sent: false,
                    seen: false
                };
                storeMessageInHistory(localMsg, friend.user_id);

                // Send via WebSocket
                if (wsConnection && wsConnection.readyState === WebSocket.OPEN) {
                    try {
                        wsConnection.send(JSON.stringify(forwardedMessage));
                    } catch (err) {
                        console.error('Failed to forward message:', err);
                    }
                }
            });

            showNotification(`Message forwarded to ${selectedFriendIds.length} friend(s)`, 'success');
            closeForwardDialog();
        }

        // Forward dialog event listeners
        document.addEventListener('DOMContentLoaded', () => {
            const closeBtn = document.getElementById('closeForwardDialog');
            const cancelBtn = document.getElementById('cancelForward');
            const confirmBtn = document.getElementById('confirmForward');
            const searchInput = document.getElementById('forwardSearch');
            const backdrop = document.querySelector('#forwardDialog .dialog-backdrop');

            if (closeBtn) closeBtn.addEventListener('click', closeForwardDialog);
            if (cancelBtn) cancelBtn.addEventListener('click', closeForwardDialog);
            if (confirmBtn) confirmBtn.addEventListener('click', forwardMessageToSelected);
            if (backdrop) backdrop.addEventListener('click', closeForwardDialog);

            // Search filter
            if (searchInput) {
                searchInput.addEventListener('input', (e) => {
                    const query = e.target.value.toLowerCase();
                    if (!query) {
                        renderForwardFriendsList(friends);
                    } else {
                        const filtered = friends.filter(f =>
                            f.username.toLowerCase().includes(query)
                        );
                        renderForwardFriendsList(filtered);
                    }
                });
            }
        });

        // VOICE RECORDING FUNCTIONALITY
        let mediaRecorder = null;
        let audioChunks = [];
        let recordingStartTime = null;
        let recordingTimerInterval = null;
        let currentAudioBlob = null;

        async function startVoiceRecording() {
            if (!currentPeer) {
                showNotification('Please select a contact first', 'error');
                return;
            }

            try {
                // Request microphone permission
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });

                // Initialize MediaRecorder
                mediaRecorder = new MediaRecorder(stream);
                audioChunks = [];

                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        audioChunks.push(event.data);
                    }
                };

                mediaRecorder.onstop = async () => {
                    // Create audio blob
                    currentAudioBlob = new Blob(audioChunks, { type: 'audio/webm' });

                    // Stop all tracks
                    stream.getTracks().forEach(track => track.stop());
                };

                // Start recording
                mediaRecorder.start();
                recordingStartTime = Date.now();

                // Show recording UI
                const recordingUI = document.getElementById('voiceRecordingUI');
                const recordBtn = document.getElementById('voice-record-btn');
                recordingUI.classList.remove('hidden');
                recordBtn.classList.add('recording');

                // Start timer
                startRecordingTimer();

                // Auto-stop after 60 seconds (like IMO)
                setTimeout(() => {
                    if (mediaRecorder && mediaRecorder.state === 'recording') {
                        stopAndSendVoiceRecording();
                    }
                }, 60000);

            } catch (error) {
                console.error('Microphone access error:', error);
                if (error.name === 'NotAllowedError') {
                    showNotification('Microphone permission denied', 'error');
                } else {
                    showNotification('Could not access microphone', 'error');
                }
            }
        }

        function startRecordingTimer() {
            const timerDisplay = document.getElementById('recordingTimer');
            recordingTimerInterval = setInterval(() => {
                const elapsed = Math.floor((Date.now() - recordingStartTime) / 1000);
                const minutes = Math.floor(elapsed / 60);
                const seconds = elapsed % 60;
                timerDisplay.textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
            }, 1000);
        }

        function stopRecordingTimer() {
            if (recordingTimerInterval) {
                clearInterval(recordingTimerInterval);
                recordingTimerInterval = null;
            }
        }

        function cancelVoiceRecording() {
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.stop();
            }

            stopRecordingTimer();

            // Hide recording UI
            const recordingUI = document.getElementById('voiceRecordingUI');
            const recordBtn = document.getElementById('voice-record-btn');
            recordingUI.classList.add('hidden');
            recordBtn.classList.remove('recording');

            // Reset
            const timerDisplay = document.getElementById('recordingTimer');
            timerDisplay.textContent = '00:00';
            audioChunks = [];
            currentAudioBlob = null;
        }

        async function stopAndSendVoiceRecording() {
            if (!mediaRecorder || mediaRecorder.state !== 'recording') return;

            // Stop recording
            mediaRecorder.stop();
            stopRecordingTimer();

            // Wait a bit for the blob to be ready
            await new Promise(resolve => setTimeout(resolve, 100));

            if (!currentAudioBlob) {
                showNotification('Recording failed', 'error');
                cancelVoiceRecording();
                return;
            }

            // Calculate duration
            const duration = Math.floor((Date.now() - recordingStartTime) / 1000);

            // Convert blob to base64
            const reader = new FileReader();
            reader.onloadend = () => {
                const base64Audio = reader.result.split(',')[1];

                // Send voice message
                sendVoiceMessage(base64Audio, duration);

                // Hide recording UI
                const recordingUI = document.getElementById('voiceRecordingUI');
                const recordBtn = document.getElementById('voice-record-btn');
                recordingUI.classList.add('hidden');
                recordBtn.classList.remove('recording');

                // Reset timer display
                const timerDisplay = document.getElementById('recordingTimer');
                timerDisplay.textContent = '00:00';
            };

            reader.readAsDataURL(currentAudioBlob);
        }

        function sendVoiceMessage(audioData, duration) {
            if (!currentUser || !currentPeer) return;

            const voiceMessage = {
                type: 'voice_message',
                from: currentUser.username,
                from_id: currentUser.id || currentUser.user_id,
                to: currentPeer.username,
                to_id: currentPeer.user_id,
                audio_data: audioData,
                duration: duration,
                client_id: 'voice_' + Date.now(),
                timestamp: new Date().toISOString()
            };

            // Store in local history
            const localMsg = {
                id: voiceMessage.client_id,
                sender_id: currentUser.id || currentUser.user_id,
                sender_username: currentUser.username,
                receiver_id: currentPeer.user_id,
                message: '[Voice Message]',
                type: 'voice',
                audio_data: audioData,
                duration: duration,
                timestamp: voiceMessage.timestamp,
                is_outgoing: true,
                sent: false,
                seen: false
            };
            storeMessageInHistory(localMsg, currentPeer.user_id);

            // Add to UI
            addVoiceMessageToUI(localMsg, true);

            // Send via WebSocket
            if (wsConnection && wsConnection.readyState === WebSocket.OPEN) {
                try {
                    wsConnection.send(JSON.stringify(voiceMessage));
                    showNotification('Voice message sent', 'success');
                } catch (err) {
                    console.error('Failed to send voice message:', err);
                    showNotification('Failed to send voice message', 'error');
                }
            }
        }

        function addVoiceMessageToUI(voiceData, isOutgoing = false) {
            const messageEl = document.createElement('div');
            messageEl.className = `message ${isOutgoing ? 'outgoing' : 'incoming'}`;

            const duration = voiceData.duration || 0;
            const minutes = Math.floor(duration / 60);
            const seconds = duration % 60;
            const durationText = `${minutes}:${String(seconds).padStart(2, '0')}`;

            const audioId = 'audio_' + voiceData.id;

            messageEl.innerHTML = `
                ${!isOutgoing ? `<div class="message-sender">${voiceData.sender_username || 'Unknown'}</div>` : ''}
                <div class="voice-message">
                    <button class="voice-play-btn" onclick="toggleVoicePlayback('${audioId}', this)">
                        <i class="fas fa-play"></i>
                    </button>
                    <div class="voice-progress">
                        <div class="voice-progress-bar" onclick="seekVoiceMessage('${audioId}', event)">
                            <div class="voice-progress-fill" id="${audioId}-progress"></div>
                        </div>
                        <div class="voice-time" id="${audioId}-time">0:00 / ${durationText}</div>
                    </div>
                    <audio id="${audioId}" preload="metadata">
                        <source src="data:audio/webm;base64,${voiceData.audio_data}" type="audio/webm">
                    </audio>
                </div>
                <div class="message-time">${new Date(voiceData.timestamp).toLocaleTimeString()}</div>
            `;

            // Attach message id
            if (voiceData.id) messageEl.dataset.msgId = voiceData.id;

            // Add delete buttons (like text messages)
            const convTargetId = isOutgoing ? (voiceData.receiver_id || currentPeer?.user_id) : (voiceData.sender_id || currentPeer?.user_id);

            const deleteForMeBtn = document.createElement('button');
            deleteForMeBtn.className = 'msg-delete-me btn-small';
            deleteForMeBtn.textContent = 'Delete for me';
            deleteForMeBtn.style.display = 'none'; // Hidden by default
            deleteForMeBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                deleteLocalMessage(messageEl.dataset.msgId, convTargetId);
            });
            messageEl.appendChild(deleteForMeBtn);

            if (isOutgoing) {
                const deleteForEveryoneBtn = document.createElement('button');
                deleteForEveryoneBtn.className = 'msg-delete btn-small';
                deleteForEveryoneBtn.textContent = 'Delete for everyone';
                deleteForEveryoneBtn.style.display = 'none'; // Hidden by default
                deleteForEveryoneBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    deleteMessageForEveryone(messageEl.dataset.msgId, convTargetId);
                });
                messageEl.appendChild(deleteForEveryoneBtn);
            }

            // Show delete buttons on message hover
            messageEl.addEventListener('mouseenter', () => {
                deleteForMeBtn.style.display = 'inline-block';
                if (isOutgoing) {
                    messageEl.querySelector('.msg-delete')?.style.setProperty('display', 'inline-block');
                }
            });

            messageEl.addEventListener('mouseleave', () => {
                deleteForMeBtn.style.display = 'none';
                if (isOutgoing) {
                    messageEl.querySelector('.msg-delete')?.style.setProperty('display', 'none');
                }
            });

            // Add click handler for options menu (like text messages)
            messageEl.addEventListener('click', (e) => {
                e.stopPropagation();
                showMessageOptions(messageEl, voiceData, isOutgoing);
            });

            // Add status for outgoing messages
            if (isOutgoing) {
                const status = document.createElement('span');
                status.className = 'msg-status pending';
                status.title = 'Pending';
                messageEl.appendChild(status);
            }

            chatMessages.appendChild(messageEl);
            scrollToBottom();

            // Set up audio element event listeners
            const audio = document.getElementById(audioId);
            if (audio) {
                audio.addEventListener('timeupdate', () => updateVoiceProgress(audioId));
                audio.addEventListener('ended', () => resetVoicePlayer(audioId));
            }
        }

        function toggleVoicePlayback(audioId, button) {
            const audio = document.getElementById(audioId);
            if (!audio) return;

            const icon = button.querySelector('i');

            if (audio.paused) {
                audio.play();
                icon.classList.remove('fa-play');
                icon.classList.add('fa-pause');
            } else {
                audio.pause();
                icon.classList.remove('fa-pause');
                icon.classList.add('fa-play');
            }
        }

        function updateVoiceProgress(audioId) {
            const audio = document.getElementById(audioId);
            const progressFill = document.getElementById(`${audioId}-progress`);
            const timeDisplay = document.getElementById(`${audioId}-time`);

            if (!audio || !progressFill || !timeDisplay) return;

            const progress = (audio.currentTime / audio.duration) * 100;
            progressFill.style.width = progress + '%';

            const currentMin = Math.floor(audio.currentTime / 60);
            const currentSec = Math.floor(audio.currentTime % 60);
            const totalMin = Math.floor(audio.duration / 60);
            const totalSec = Math.floor(audio.duration % 60);

            timeDisplay.textContent = `${currentMin}:${String(currentSec).padStart(2, '0')} / ${totalMin}:${String(totalSec).padStart(2, '0')}`;
        }

        function seekVoiceMessage(audioId, event) {
            const audio = document.getElementById(audioId);
            const progressBar = event.currentTarget;

            if (!audio || !progressBar) return;

            const rect = progressBar.getBoundingClientRect();
            const pos = (event.clientX - rect.left) / rect.width;
            audio.currentTime = pos * audio.duration;
        }

        function resetVoicePlayer(audioId) {
            const audio = document.getElementById(audioId);
            const button = audio.closest('.voice-message').querySelector('.voice-play-btn');
            const icon = button.querySelector('i');

            icon.classList.remove('fa-pause');
            icon.classList.add('fa-play');
            audio.currentTime = 0;
        }

        // Voice recording button event listener
        document.addEventListener('DOMContentLoaded', () => {
            const voiceRecordBtn = document.getElementById('voice-record-btn');
            const cancelRecordingBtn = document.getElementById('cancelRecording');
            const sendRecordingBtn = document.getElementById('sendRecording');

            if (voiceRecordBtn) {
                voiceRecordBtn.addEventListener('click', () => {
                    if (!mediaRecorder || mediaRecorder.state !== 'recording') {
                        startVoiceRecording();
                    }
                });
            }

            if (cancelRecordingBtn) {
                cancelRecordingBtn.addEventListener('click', cancelVoiceRecording);
            }

            if (sendRecordingBtn) {
                sendRecordingBtn.addEventListener('click', stopAndSendVoiceRecording);
            }
        });

        // MESSAGE HANDLING - COMPATIBLE WITH YOUR FLASK BACKEND
        // Helper to convert selector value to seconds
        function parseSelfDestructValue(val) {
            switch (val) {
                case '5s': return 5;
                case '10s': return 10;
                case '1m': return 60;
                case '1h': return 3600;
                case '1d': return 86400;
                default: return 0;
            }
        }
        // Best-effort screenshot detection heuristics
        (function installScreenshotDetection(){
            const showScreenshotWarning = (reason) => {
                const banner = document.getElementById('screenshotWarningBanner');
                const msg = document.getElementById('screenshotBannerMsg');
                if (msg) msg.textContent = `A screenshot may have been taken (reason: ${reason}).`;
                if (banner) {
                    banner.style.display = 'flex';
                    banner.style.animation = 'screenshotPulse 1s ease-in-out 0s 3';
                }
                showNotification('Possible screenshot detected — this is best-effort', 'error');
                // briefly highlight then fade depending on detection
                setTimeout(() => {
                    try { banner.style.animation = ''; } catch (e) {}
                }, 3000);
            };

            // visibilitychange: user switched away quickly (common when taking screenshots on some platforms)
            document.addEventListener('visibilitychange', () => {
                try {
                    const enabled = (localStorage.getItem('screenshot_protection_enabled') || '0') === '1';
                    if (!enabled) return;
                    if (document.hidden) {
                        // mark possible screenshot after short delay
                        setTimeout(() => showScreenshotWarning('visibilitychange'), 500);
                    }
                } catch (e) { }
            });

            // blur event (window lost focus)
            window.addEventListener('blur', () => {
                try {
                    const enabled = (localStorage.getItem('screenshot_protection_enabled') || '0') === '1';
                    if (!enabled) return;
                    showScreenshotWarning('window blur');
                } catch (e) { }
            });

            // Try to capture PrintScreen keypress (may not work on all platforms/browsers)
            window.addEventListener('keydown', (e) => {
                try {
                    const enabled = (localStorage.getItem('screenshot_protection_enabled') || '0') === '1';
                    if (!enabled) return;
                    if (e.key === 'PrintScreen' || e.code === 'PrintScreen') {
                        showScreenshotWarning('PrintScreen key');
                    }
                } catch (e) { }
            });

            // Also monitor paste events carrying images (someone used clipboard screenshot)
            window.addEventListener('paste', (e) => {
                try {
                    const enabled = (localStorage.getItem('screenshot_protection_enabled') || '0') === '1';
                    if (!enabled) return;
                    const items = (e.clipboardData && e.clipboardData.items) || [];
                    for (let i=0;i<items.length;i++) {
                        if (items[i].type && items[i].type.indexOf('image') !== -1) {
                            showScreenshotWarning('image pasted from clipboard');
                            break;
                        }
                    }
                } catch (e) { }
            });
        })();
        function sendMessage() {
            if (!currentUser) {
                showNotification('Please login first', 'error');
                return;
            }

            const text = messageInput.value.trim();
            if (text === '') return;

            if (!currentPeer) {
                showNotification('Please select a contact first', 'error');
                return;
            }

            // Check if sending to a group
            const isGroup = currentPeer.is_group || (currentPeer.group_id !== undefined);

            // 🛡️ SECURITY CHECK: Verify currentPeer is an accepted friend OR it is a group
            const isFriend = friends.some(friend =>
                friend.user_id === currentPeer.user_id ||
                friend.username === currentPeer.username
            );

            if (!isFriend && !isGroup) {
                showNotification('You can only message accepted friends. Send a friend request first!', 'error');
                return;
            }

            // Read self-destruct selection; if 'off', consult default settings from localStorage
            const sdSelect = document.getElementById('msgSelfDestructSelect');
            const sdValue = sdSelect ? sdSelect.value : 'off';
            let sdSeconds = parseSelfDestructValue(sdValue);

            if (sdSeconds === 0) {
                try {
                    const defSec = parseInt(localStorage.getItem('default_self_destruct_seconds') || '0', 10);
                    const defEnabled = (localStorage.getItem('default_self_destruct_enabled') || '0') === '1';
                    const defApplyPrivate = (localStorage.getItem('default_self_destruct_apply_private') || '1') === '1';
                    const defApplyGroup = (localStorage.getItem('default_self_destruct_apply_group') || '0') === '1';

                    // apply only if enabled and applies to this conversation type
                    if (defEnabled) {
                        if ((!isGroup && defApplyPrivate) || (isGroup && defApplyGroup)) {
                            sdSeconds = defSec || 0;
                        }
                    }
                } catch (e) { /* ignore */ }
            }

            // Format message for your Flask backend
            let messageData;
            if (isGroup) {
                messageData = {
                    type: 'group_message',
                    from: currentUser.username,
                    from_id: currentUser.id || currentUser.user_id,
                    group_id: currentPeer.group_id,
                    message: text,
                    client_id: 'temp_' + Date.now(),
                    timestamp: new Date().toISOString(),
                    self_destruct_seconds: sdSeconds,
                    self_destruct_at: sdSeconds > 0 ? new Date(Date.now() + sdSeconds * 1000).toISOString() : null
                };
            } else {
                messageData = {
                    type: 'send_message',
                    from: currentUser.username,
                    from_id: currentUser.id || currentUser.user_id,
                    to: currentPeer.username,
                    to_id: currentPeer.user_id,
                    message: text,
                    client_id: 'temp_' + Date.now(),
                    timestamp: new Date().toISOString(),
                    self_destruct_seconds: sdSeconds,
                    self_destruct_at: sdSeconds > 0 ? new Date(Date.now() + sdSeconds * 1000).toISOString() : null
                };
            }

            // Store message in local history
            const targetId = isGroup ? `group_${currentPeer.group_id}` : currentPeer.user_id;

            const localMsg = {
                id: messageData.client_id,
                sender_id: currentUser.id || currentUser.user_id,
                sender_username: currentUser.username,
                receiver_id: isGroup ? null : currentPeer.user_id,
                group_id: isGroup ? currentPeer.group_id : null,
                message: text,
                timestamp: new Date().toISOString(),
                is_outgoing: true,
                sent: false,
                seen: false,
                deleted_request: false,
                is_friend_message: !isGroup // Mark as friend message only if not group
                ,self_destruct_seconds: sdSeconds,
                self_destruct_at: sdSeconds > 0 ? new Date(Date.now() + sdSeconds * 1000).toISOString() : null
            };
            storeMessageInHistory(localMsg, targetId);

            // Add to UI immediately
            try {
                addMessageToUI(localMsg);
            } catch (uiErr) {
                console.error('Failed to add outgoing message to UI:', uiErr);
            }

            // Try sending over WebSocket
            if (wsConnection && wsConnection.readyState === WebSocket.OPEN) {
                try {
                    wsConnection.send(JSON.stringify(messageData));
                } catch (sendErr) {
                    console.error('WebSocket send failed:', sendErr);
                    showNotification('Failed to send message to server; saved locally.', 'error');
                }
            } else {
                showNotification('Offline: message saved locally and will be sent when connected', 'info');
            }

            messageInput.value = '';

            // Schedule local deletion if requested
            if (sdSeconds > 0) {
                try {
                    setTimeout(() => {
                        // deleteLocalMessage handles UI + local storage removal
                        deleteLocalMessage(localMsg.id, targetId);
                    }, sdSeconds * 1000);
                } catch (err) {
                    console.warn('Failed to schedule self-destruct:', err);
                }
            }
        }

        function storeMessageInHistory(message, targetId) {
            if (!messageHistory[targetId]) {
                messageHistory[targetId] = [];
            }
            messageHistory[targetId].push(message);
            // Persist this conversation to localStorage so history survives reloads
            try {
                const key = `msg_history_${targetId}`;
                localStorage.setItem(key, JSON.stringify(messageHistory[targetId]));
            } catch (err) {
                console.warn('Failed to persist message history:', err);
            }
        }

        function loadMessageHistoryFor(targetId) {
            if (messageHistory[targetId] && messageHistory[targetId].length) return;
            try {
                const key = `msg_history_${targetId}`;
                const raw = localStorage.getItem(key);
                if (raw) {
                    messageHistory[targetId] = JSON.parse(raw);
                }
            } catch (err) {
                console.warn('Failed to load persisted message history:', err);
            }
            if (!messageHistory[targetId]) messageHistory[targetId] = [];
        }

        function addMessageToUI(messageData) {
            const messageEl = document.createElement('div');
            const isOutgoing = messageData.is_outgoing ||
                (messageData.sender_id === (currentUser.id || currentUser.user_id));

            messageEl.className = `message ${isOutgoing ? 'outgoing' : 'incoming'}`;

            // No inline icons visible by default — menu appears only when message is clicked
            const inlineActionsHtml = '';
            const deleteButtonsHtml = isOutgoing ?
                `<div class="msg-actions" style="display:none"><button class="msg-delete btn-small" data-action="delete-everyone">Delete for everyone</button> <button class="msg-delete-me btn-small" data-action="delete-me">Remove</button></div>` :
                `<div class="msg-actions" style="display:none"><button class="msg-delete-me btn-small" data-action="delete-me">Remove</button></div>`;

            const selfDestructHtml = messageData.self_destruct_at ?
                `<div class="self-destruct-badge" title="Will self-destruct at ${new Date(messageData.self_destruct_at).toLocaleTimeString()}">⏳</div>` : '';

            messageEl.innerHTML = `
        ${!isOutgoing && currentGroup ? `<div class="message-sender">${messageData.sender_username || 'Unknown'}</div>` : ''}
        <div class="message-text">${messageData.message}</div>
        <div style="display:flex;align-items:center;justify-content:space-between;">
            <div style="display:flex;gap:8px;align-items:center;"><div class="message-time">${new Date(messageData.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}</div>${selfDestructHtml}</div>
            ${inlineActionsHtml}
        </div>
        ${deleteButtonsHtml}
    `;

            // Attach message id for later lookup (may be temp id initially)
            if (messageData.id) messageEl.dataset.msgId = messageData.id;
            // Add a status indicator for outgoing text messages
            if (isOutgoing) {
                const status = document.createElement('span');
                status.className = 'msg-status pending';
                status.title = 'Pending';
                // reflect persisted state if available
                if (messageData.seen) {
                    status.classList.remove('pending');
                    status.classList.add('seen');
                    status.title = 'Seen';
                } else if (messageData.sent) {
                    status.classList.remove('pending');
                    status.classList.add('delivered');
                    status.title = 'Delivered';
                }
                messageEl.appendChild(status);
            }

            chatMessages.appendChild(messageEl);
            scrollToBottom();

            // Determine conversation target id: for outgoing use receiver_id, for incoming use sender_id
            const convTargetId = isOutgoing ? (messageData.receiver_id || currentPeer?.user_id) : (messageData.sender_id || currentPeer?.user_id);
            // Wire up delete action handlers
            const deleteBtn = messageEl.querySelector('.msg-delete');
            const deleteMeBtn = messageEl.querySelector('.msg-delete-me');
            if (deleteBtn) deleteBtn.addEventListener('click', () => deleteMessageForEveryone(messageEl.dataset.msgId, convTargetId));
            if (deleteMeBtn) deleteMeBtn.addEventListener('click', () => deleteLocalMessage(messageEl.dataset.msgId, convTargetId));

            // Show options on click (Edit/Delete) — available for both incoming and outgoing messages.
            messageEl.addEventListener('click', (e) => {
                e.stopPropagation();
                showMessageOptions(messageEl, messageData, isOutgoing);
            });
        }

        // Show a small inline options menu when a message is clicked
        function showMessageOptions(messageEl, messageData, isOutgoing) {
            // Remove any existing menus
            document.querySelectorAll('.msg-menu').forEach(m => m.remove());

            const menu = document.createElement('div');
            menu.className = 'msg-menu';
            menu.style.cssText = 'position: absolute; right: 10px; top: -10px; background: #fff; border: 1px solid #ddd; padding: 6px; border-radius:6px; z-index:1000; box-shadow:0 6px 18px rgba(0,0,0,0.12);';
            // Quick Reply button (IMO-style) - inserts a quoted reply into input
            const quickReplyBtn = document.createElement('button');
            quickReplyBtn.className = 'btn-small';
            quickReplyBtn.innerHTML = '<i class="fa fa-reply"></i>';
            quickReplyBtn.title = 'Quick Reply';
            quickReplyBtn.style.marginRight = '6px';
            quickReplyBtn.addEventListener('click', (ev) => {
                ev.stopPropagation();
                // Insert a quoted reply into the message input
                const textEl = messageEl.querySelector('.message-text');
                const sender = messageData.sender_username || (isOutgoing ? (currentUser && currentUser.username) : 'Unknown');
                const quoted = textEl ? textEl.textContent : '';
                // Format as a simple quote line followed by a space for typing
                messageInput.value = `> ${sender}: ${quoted}\n`;
                messageInput.focus();
                menu.remove();
            });
            menu.appendChild(quickReplyBtn);

            // Copy button - copies message text to clipboard
            const copyBtn = document.createElement('button');
            copyBtn.className = 'btn-small';
            copyBtn.innerHTML = '<i class="fa fa-copy"></i>';
            copyBtn.title = 'Copy message';
            copyBtn.style.marginRight = '6px';
            copyBtn.addEventListener('click', async (ev) => {
                ev.stopPropagation();
                const textEl = messageEl.querySelector('.message-text');
                const textToCopy = textEl ? textEl.textContent : '';
                try {
                    await navigator.clipboard.writeText(textToCopy);
                    showNotification('Message copied to clipboard', 'success');
                } catch (err) {
                    // Fallback for older browsers
                    const ta = document.createElement('textarea');
                    ta.value = textToCopy;
                    document.body.appendChild(ta);
                    ta.select();
                    try { document.execCommand('copy'); showNotification('Message copied to clipboard', 'success'); } catch (e) { showNotification('Copy failed', 'error'); }
                    ta.remove();
                }
                menu.remove();
            });
            menu.appendChild(copyBtn);

            // Forward button - forwards message to other contacts
            const forwardBtn = document.createElement('button');
            forwardBtn.className = 'btn-small';
            forwardBtn.innerHTML = '<i class="fa fa-share"></i>';
            forwardBtn.title = 'Forward message';
            forwardBtn.style.marginRight = '6px';
            forwardBtn.addEventListener('click', (ev) => {
                ev.stopPropagation();
                openForwardDialog(messageData);
                menu.remove();
            });
            menu.appendChild(forwardBtn);

            // Delete for me
            const delMe = document.createElement('button');
            delMe.className = 'btn-small';
            delMe.innerHTML = '<i class="fa fa-trash"></i>';
            delMe.title = 'Delete for me';
            delMe.addEventListener('click', (ev) => {
                ev.stopPropagation();
                const convTarget = isOutgoing ? (messageData.receiver_id || currentPeer?.user_id) : (messageData.sender_id || currentPeer?.user_id);
                deleteLocalMessage(messageEl.dataset.msgId, convTarget);
                menu.remove();
            });
            menu.appendChild(delMe);

            if (isOutgoing) {
                // Edit button for outgoing messages
                const editBtn = document.createElement('button');
                editBtn.className = 'btn-small';
                editBtn.innerHTML = '<i class="fa fa-edit"></i>';
                editBtn.title = 'Edit message';
                editBtn.style.marginLeft = '8px';
                editBtn.addEventListener('click', (ev) => {
                    ev.stopPropagation();
                    startEditMessage(messageEl, messageData);
                    menu.remove();
                });
                menu.appendChild(editBtn);

                // Delete for everyone
                const delAll = document.createElement('button');
                delAll.className = 'btn-small';
                delAll.innerHTML = '<i class="fa fa-user-slash"></i>';
                delAll.title = 'Delete for everyone';
                delAll.style.marginLeft = '8px';
                delAll.addEventListener('click', (ev) => {
                    ev.stopPropagation();
                    const convTarget = messageData.receiver_id || currentPeer?.user_id;
                    deleteMessageForEveryone(messageEl.dataset.msgId, convTarget);
                    menu.remove();
                });
                menu.appendChild(delAll);
            }

            // Position menu relative to message element
            messageEl.style.position = 'relative';
            messageEl.appendChild(menu);

            // Close menu if clicking elsewhere. Use a single global closer to avoid
            // adding many document listeners. The closer will remove any open .msg-menu
            // elements when clicking outside them.
            if (!window._msgMenuGlobalCloserAdded) {
                window._msgMenuGlobalCloserAdded = true;
                document.addEventListener('click', (ev) => {
                    document.querySelectorAll('.msg-menu').forEach(m => {
                        if (!m.contains(ev.target)) m.remove();
                    });
                });

                // Also remove menus on scroll inside chat messages
                chatMessages.addEventListener('scroll', () => {
                    document.querySelectorAll('.msg-menu').forEach(m => m.remove());
                });
            }
        }

        function startEditMessage(messageEl, messageData) {
            const msgId = messageEl.dataset.msgId;
            if (!msgId || String(msgId).startsWith('temp_')) {
                showNotification('Cannot edit before message is delivered', 'error');
                return;
            }

            const textEl = messageEl.querySelector('.message-text');
            if (!textEl) return;

            const orig = textEl.textContent;
            // Create input and action buttons
            const input = document.createElement('input');
            input.type = 'text';
            input.value = orig;
            input.style.width = '70%';
            input.style.marginRight = '6px';

            const saveBtn = document.createElement('button');
            saveBtn.className = 'btn-small';
            saveBtn.textContent = 'Save';

            const cancelBtn = document.createElement('button');
            cancelBtn.className = 'btn-small';
            cancelBtn.textContent = 'Cancel';
            cancelBtn.style.marginLeft = '6px';

            const container = document.createElement('div');
            container.style.display = 'flex';
            container.style.alignItems = 'center';
            container.appendChild(input);
            container.appendChild(saveBtn);
            container.appendChild(cancelBtn);

            // Replace text element with the editor
            textEl.style.display = 'none';
            messageEl.insertBefore(container, textEl.nextSibling);

            cancelBtn.addEventListener('click', () => {
                container.remove();
                textEl.style.display = '';
            });

            saveBtn.addEventListener('click', () => {
                const newText = input.value.trim();
                if (newText === '') return showNotification('Message cannot be empty', 'error');

                // Update UI optimistically
                textEl.textContent = newText;
                container.remove();
                textEl.style.display = '';

                // Update local history
                Object.keys(messageHistory).forEach(targetId => {
                    const arr = messageHistory[targetId];
                    const m = arr.find(x => String(x.id) === String(msgId));
                    if (m) {
                        m.message = newText;
                        try { localStorage.setItem(`msg_history_${targetId}`, JSON.stringify(arr)); } catch (e) { }
                    }
                });

                // Send edit request to server
                if (wsConnection && wsConnection.readyState === WebSocket.OPEN) {
                    try {
                        wsConnection.send(JSON.stringify({ type: 'edit_message', message_id: Number(msgId), new_message: newText }));
                    } catch (err) {
                        console.error('Failed to send edit request:', err);
                        showNotification('Edit request failed', 'error');
                    }
                } else {
                    showNotification('Offline: edit saved locally; server will not be updated until reconnect', 'info');
                }
            });
        }

        // MESSAGE HANDLER - COMPATIBLE WITH YOUR FLASK BACKEND
        async function handleRealMessage(data) {
            console.log('📨 Handling real message from backend:', data);

            switch (data.type) {
                case 'user_registered':
                    showNotification(`Connected as ${data.username} in real chat`);
                    dhtStatusText.textContent = 'Connected - Online';
                    break;

                case 'peer_list':
                    updatePeersList(data.peers);
                    break;

                case 'group_list':
                    // Merge server groups with local groups (preserving temp ones)
                    const tempGroups = groups.filter(g => String(g.id).startsWith('g_temp_'));
                    const serverGroups = data.groups || [];
                    groups = [...serverGroups, ...tempGroups];
                    persistGroups();
                    renderGroupsList();
                    // If we have a pending group open request (from join), open it now
                    try{
                        if(pendingOpenGroupId){
                            const g = groups.find(x => String(x.id) === String(pendingOpenGroupId));
                            if(g){
                                pendingOpenGroupId = null;
                                openGroupChat(g);
                            } else {
                                // clear anyway after short timeout
                                setTimeout(()=>{ pendingOpenGroupId = null; }, 1000);
                            }
                        }
                    }catch(e){ console.warn('Auto-open group error', e); }
                    break;

                case 'group_created':
                    // Check if we have a temp group with matching client_id
                    let tempGroupIdx = -1;
                    if (data.client_id) {
                        tempGroupIdx = groups.findIndex(g => g.id === data.client_id);
                    }

                    if (tempGroupIdx !== -1) {
                        // Update existing entry
                        const oldId = groups[tempGroupIdx].id;
                        groups[tempGroupIdx].id = data.group_id;
                        groups[tempGroupIdx].name = data.group_name;

                        // Migrate message history
                        if (messageHistory[`group_${oldId}`]) {
                            messageHistory[`group_${data.group_id}`] = messageHistory[`group_${oldId}`];
                            delete messageHistory[`group_${oldId}`];

                            // Migrate localStorage
                            try {
                                const oldKey = `msg_history_group_${oldId}`;
                                const raw = localStorage.getItem(oldKey);
                                if (raw) {
                                    localStorage.setItem(`msg_history_group_${data.group_id}`, raw);
                                    localStorage.removeItem(oldKey);
                                }
                            } catch (e) { }
                        }

                        // If we are currently viewing this group, update currentPeer/currentGroup
                        if (currentGroup && String(currentGroup.id) === String(oldId)) {
                            currentGroup.id = data.group_id;
                            currentPeer.group_id = data.group_id;
                            showNotification('Group created successfully (synced)', 'success');
                        }
                    } else {
                        // New group added by someone else (or missed temp)
                        const exists = groups.some(g => String(g.id) === String(data.group_id));
                        if (!exists) {
                            groups.push({
                                id: data.group_id,
                                name: data.group_name,
                                members: data.members
                            });
                            showNotification(`Added to group: ${data.group_name}`, 'info');
                        }
                    }
                    persistGroups();
                    renderGroupsList();
                    break;

                case 'group_member_added':
                    try{
                        // ensure groups list has this group and update members
                        const gid = data.group_id || data.groupId || data.groupId;
                        const addedUser = data.added_user || (data.member && data.member.username) || data.added_by || data.added_by;
                        const gidx = groups.findIndex(x => String(x.id) === String(gid));
                        if (gidx !== -1) {
                            const g = groups[gidx];
                            g.members = g.members || [];
                            // members may be sent as usernames or objects
                            if (data.member) {
                                g.members.push(data.member.username || data.member.user_id || data.member.id);
                            } else if (addedUser) {
                                g.members.push(addedUser);
                            }
                            // persist and rerender sidebar
                            persistGroups(); renderGroupsList();
                            // if currently viewing this group, update UI
                            if (currentGroup && String(currentGroup.id) === String(gid)) {
                                currentGroup.members = g.members;
                                renderGroupMembers(currentGroup.members);
                                showNotification(`${addedUser} added to group`, 'info');
                            }
                        }
                    }catch(e){ console.warn('group_member_added handler failed', e); }
                    break;

                case 'group_members_updated':
                    try{
                        const gid = data.group_id || data.groupId;
                        const updated = data.members || data.updated_members || [];
                        const gidx = groups.findIndex(x => String(x.id) === String(gid));
                        if (gidx !== -1) {
                            groups[gidx].members = Array.isArray(updated) ? updated.slice() : groups[gidx].members || [];
                            persistGroups(); renderGroupsList();
                        }
                        if (currentGroup && String(currentGroup.id) === String(gid)) {
                            currentGroup.members = Array.isArray(updated) ? updated.slice() : currentGroup.members || [];
                            renderGroupMembers(currentGroup.members);
                            showNotification('Group membership updated', 'info');
                        }
                    }catch(e){ console.warn('group_members_updated handler failed', e); }
                    break;

                case 'public_groups':
                    // Server responded with a list of public/discoverable groups
                    try{ renderDiscoverGroupsList(data.groups || []); }catch(e){ console.warn('Failed to render public groups', e); }
                    break;

                case 'join_group_ack':
                    // Acknowledgement for join attempt
                    try{
                        if(data.status === 'joined'){
                            showNotification('You joined the group', 'success');
                            // remember to auto-open the group when the list arrives
                            try{
                                pendingOpenGroupId = data.group_id || data.groupId || data.groupId;
                                if(window.wsConnection && window.wsConnection.readyState===1) window.wsConnection.send(JSON.stringify({ type: 'get_groups' }));
                            } catch(e){}
                        } else if(data.status === 'already_member'){
                            showNotification('You are already a member of this group', 'info');
                        } else if(data.status === 'failed'){
                            showNotification(data.reason || 'Failed to join group', 'error');
                        }
                    }catch(e){ console.warn('join_group_ack handler error', e); }
                    break;

                case 'group_message':
                    console.log('👥 Received group message:', data);
                    const groupMsg = {
                        id: data.id || data.client_id,
                        sender_id: data.from_id,
                        sender_username: data.from,
                        group_id: data.group_id,
                        message: data.message,
                        timestamp: data.timestamp || new Date().toISOString(),
                        is_outgoing: false,
                        type: 'text'
                    };

                    // Store in history
                    storeMessageInHistory(groupMsg, `group_${data.group_id}`);

                    // Update UI if viewing this group
                    if (currentGroup && String(currentGroup.id) === String(data.group_id)) {
                        addMessageToUI(groupMsg);
                    } else {
                        // Notify
                        showNotificationWithSound(`New message in group (ID: ${data.group_id}) from ${data.from}`, 'info', true);
                    }
                    break;



                case 'group_history':
                    if (data.messages && data.messages.length > 0) {
                        const groupId = data.group_id;
                        const key = `group_${groupId}`;

                        // Merge with existing
                        let existing = messageHistory[key] || [];
                        const existingIds = new Set(existing.map(m => m.id || m.timestamp)); // use timestamp as fallback unique key if id missing

                        let updated = false;
                        data.messages.forEach(serverMsg => {
                            // serverMsg has simple structure, map to UI structure
                            const msg = {
                                id: serverMsg.id,
                                sender_id: serverMsg.sender_id,
                                sender_username: serverMsg.sender_username,
                                group_id: serverMsg.group_id,
                                message: serverMsg.message,
                                timestamp: serverMsg.timestamp,
                                is_outgoing: serverMsg.is_outgoing,
                                type: 'text',
                                seen: true
                            };

                            if (!existingIds.has(msg.id)) {
                                existing.push(msg);
                                updated = true;
                            }
                        });

                        if (updated) {
                            // Sort by timestamp
                            existing.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
                            messageHistory[key] = existing;
                            try { localStorage.setItem(`msg_history_group_${groupId}`, JSON.stringify(existing)); } catch (e) { }

                            // If viewing this group, re-render
                            if (currentGroup && String(currentGroup.id) === String(groupId)) {
                                chatMessages.innerHTML = '';
                                // Re-render welcome message
                                const welcomeMsg = document.createElement('div');
                                welcomeMsg.className = 'message incoming';
                                welcomeMsg.innerHTML = `
                                <div class="message-text">💬 Group: ${escapeHtml(currentGroup.name)} (Synced) — ${(currentGroup.members || []).length} members</div>
                                <div class="message-time">${new Date().toLocaleTimeString()}</div>
                                `;
                                chatMessages.appendChild(welcomeMsg);

                                existing.forEach(m => addMessageToUI(m));
                                scrollToBottom();
                            }
                        }
                    }
                    break;

                case 'message':
                    handleIncomingMessage(data);
                    // If the user currently has this chat open, send 'seen' for this message
                    try {
                        if (currentPeer && data.sender_id === currentPeer.user_id && wsConnection && wsConnection.readyState === WebSocket.OPEN) {
                            wsConnection.send(JSON.stringify({ type: 'message_seen', message_id: data.message_id }));
                            // Also inform sender via DOM update (we will receive message_seen event back from server)
                        }
                    } catch (err) { console.warn('Failed to send seen notification', err); }
                    break;
                case 'friend_request':
                    handleIncomingFriendRequest(data);
                    break;
                case 'friend_request_accepted':
                    handleFriendRequestAccepted(data);
                    break;
                case 'friend_request_rejected':
                    handleFriendRequestRejected(data);
                    break;

                case 'delivery_ack':
                    // Server ack includes mapping from client_id to real message_id
                    handleDeliveryAck(data);
                    break;

                case 'message_deleted':
                    handleMessageDeleted(data);
                    break;

                case 'message_edited':
                    // Update local UI for edited messages
                    const mid = String(data.message_id);
                    const el = chatMessages.querySelector(`[data-msg-id="${mid}"]`);
                    if (el) {
                        const textEl = el.querySelector('.message-text');
                        if (textEl) textEl.textContent = data.new_message;
                    }
                    // Update local history
                    Object.keys(messageHistory).forEach(targetId => {
                        const arr = messageHistory[targetId];
                        const m = arr.find(x => String(x.id) === mid);
                        if (m) { m.message = data.new_message; try { localStorage.setItem(`msg_history_${targetId}`, JSON.stringify(arr)); } catch (e) { } }
                    });
                    break;

                case 'message_seen':
                    // mark message as seen (two checks)
                    const seenId = String(data.message_id);
                    updateMessageStatusDOM(seenId, 'seen');
                    // update local history
                    Object.keys(messageHistory).forEach(targetId => {
                        const arr = messageHistory[targetId];
                        const m = arr.find(x => String(x.id) === seenId);
                        if (m) { m.seen = true; try { localStorage.setItem(`msg_history_${targetId}`, JSON.stringify(arr)); } catch (e) { } }
                    });
                    break;

                case 'file_message':
                    handleIncomingFileMessage(data);
                    break;

                case 'voice_message':
                    // Handle incoming voice messages
                    handleIncomingVoiceMessage(data);
                    break;

                case 'call_request':
                    if (!isInCall) {
                        callerAvatar.src = `https://i.pravatar.cc/150?u=${data.from}`;
                        callerName.textContent = `Incoming ${data.call_type} call from ${data.from}`;
                        callType.textContent = data.call_type === 'video' ? 'Video Call' : 'Audio Call';
                        incomingCallAlert.classList.add('active');

                        window.currentCaller = {
                            username: data.from,
                            user_id: data.from_id,
                            call_type: data.call_type
                        };
                    }
                    break;

                case 'call_accepted':
                    if (isCaller) {
                        showNotification('Call accepted! Establishing WebRTC...', 'success');
                        try {
                            // Create peer connection and attach local tracks
                            rtcPeerConnection = createPeerConnection(data.from);
                            if (localStream) {
                                localStream.getTracks().forEach(t => rtcPeerConnection.addTrack(t, localStream));
                            }

                            // Create offer
                            const offer = await rtcPeerConnection.createOffer();
                            await rtcPeerConnection.setLocalDescription(offer);

                            // Send offer via signaling
                            if (wsConnection && wsConnection.readyState === WebSocket.OPEN) {
                                wsConnection.send(JSON.stringify({
                                    type: 'webrtc_offer',
                                    to: data.from,
                                    offer: offer
                                }));
                            }
                        } catch (err) {
                            console.error('Error creating offer:', err);
                        }
                    }
                    break;

                case 'call_rejected':
                    if (isCaller) {
                        showNotification('Call rejected', 'error');
                        endCall();
                    }
                    break;

                case 'call_end':
                    if (isInCall) {
                        showNotification('Call ended by remote user', 'info');
                        endCall();
                    }
                    break;

                case 'webrtc_offer':
                    console.log('Received webrtc_offer', data);
                    handleWebrtcOffer(data);
                    break;

                case 'webrtc_answer':
                    console.log('Received webrtc_answer', data);
                    handleWebrtcAnswer(data);
                    break;

                case 'webrtc_ice_candidate':
                    // ICE candidate from remote
                    handleWebrtcIceCandidate(data);
                    break;

                case 'group_created':
                    // Server side acknowledges canonical group creation. Replace optimistic group if needed.
                    try {
                        const serverGroupId = String(data.group_id);
                        const clientId = data.client_id || data.temp_id;
                        const groupName = data.group_name || 'Unnamed Group';
                        const members = Array.isArray(data.members) ? data.members : (data.members ? [data.members] : []);

                        if (clientId) {
                            // find optimistic group and update it
                            const g = (groups || []).find(x => String(x.id) === String(clientId));
                            if (g) {
                                g.id = serverGroupId;
                                g.name = groupName;
                                g.members = members;

                                // update sidebar element
                                const el = document.querySelector(`.group-item[data-group-id="${clientId}"]`);
                                if (el) {
                                    el.dataset.groupId = serverGroupId;
                                    const nameEl = el.querySelector('.name'); if (nameEl) nameEl.textContent = g.name;
                                    const subEl = el.querySelector('.sub'); if (subEl) subEl.textContent = `${(g.members || []).length} members`;
                                }

                                // persist groups
                                try { localStorage.setItem('p2p_groups', JSON.stringify(groups)); } catch (e) { console.warn('Failed to persist groups after reconcile', e); }
                                showNotification(`Group '${g.name}' created`, 'success');
                                break;
                            }
                        }

                        // If no matching optimistic group, add new one
                        const newGroup = { id: serverGroupId, name: groupName, members: members };
                        createGroupLocal(newGroup);
                        showNotification(`Group '${newGroup.name}' created`, 'success');
                    } catch (err) {
                        console.warn('Failed handling group_created', err);
                    }
                    break;

                // FRIEND REQUEST SYSTEM - Backend Response Handlers
                case 'user_list':
                    // Backend sends all users with friend_status field
                    console.log('📋 Received user_list from backend:', data);
                    console.log('📋 Number of users:', data.users?.length);
                    allUsers = data.users || [];
                    console.log('📋 allUsers array updated:', allUsers);
                    console.log('📋 Current tab:', document.querySelector('.sidebar-tabs .tab-button.active')?.dataset.tab);
                    renderAllUsers(allUsers);
                    console.log('✅ renderAllUsers() called');
                    break;

                case 'friend_requests_list':
                    // Backend sends pending friend requests (incoming and outgoing)
                    console.log('📥 Received friend requests from backend:', data.requests);
                    friendRequests = data.requests || [];
                    saveFriendRequestsToStorage();
                    renderFriendRequestsList();
                    updateRequestCount();
                    console.log('✅ Friend requests updated:', friendRequests.length, 'pending');
                    break;

                case 'friends_list':
                    // Backend sends accepted friends list
                    console.log('👥 Received friends list from backend:', data.friends);
                    friends = data.friends || [];
                    saveFriendsToStorage();
                    renderFriendsList();
                    renderFriendsInSidebar(friends);
                    console.log('✅ Friends list updated with', friends.length, 'friends');
                    break;

                case 'error':
                    showNotification(`Error: ${data.message}`, 'error');
                    break;
            }
                    // Additional group UI helpers
                    function resolveMemberAvatarAndName(member) {
                        // member may be username string, numeric id, or object {id, username}
                        let username = null, uid = null;
                        if (!member) return { username: 'Unknown', avatar: 'https://i.pravatar.cc/150?u=unknown' };
                        if (typeof member === 'string') username = member;
                        else if (typeof member === 'number') uid = member;
                        else if (typeof member === 'object') {
                            username = member.username || member.name || null;
                            uid = member.id || member.user_id || null;
                        }

                        // try to find in allUsers or friends
                        const found = (allUsers || []).concat(friends || []).find(u => String(u.username) === String(username) || String(u.user_id || u.id) === String(uid));
                        if (found) return { username: found.username || String(found.user_id || uid), avatar: found.avatar || `https://i.pravatar.cc/150?u=${found.username || found.user_id}` };

                        // fallback avatar generation
                        const uKey = username || uid || ('m_' + Math.random().toString(36).slice(2,7));
                        return { username: username || `User ${uid || ''}`, avatar: `https://i.pravatar.cc/150?u=${uKey}` };
                    }

                    function renderGroupMembers(members) {
                        try {
                            const container = document.getElementById('group-members-list');
                            const nameEl = document.getElementById('groupInfoName');
                            const metaEl = document.getElementById('groupInfoMeta');
                            const avatarBox = document.getElementById('groupInfoAvatar');
                            if (!container) return;
                            container.innerHTML = '';
                            const arr = Array.isArray(members) ? members : [];
                            metaEl && (metaEl.textContent = `${arr.length} member${arr.length===1?'':'s'}`);
                            if (arr.length > 0 && avatarBox) {
                                const first = resolveMemberAvatarAndName(arr[0]);
                                avatarBox.textContent = '';
                                avatarBox.style.backgroundImage = `url(${first.avatar})`;
                                avatarBox.style.backgroundSize = 'cover';
                                avatarBox.style.backgroundPosition = 'center';
                            }

                            arr.forEach(m => {
                                const info = resolveMemberAvatarAndName(m);
                                const item = document.createElement('div');
                                item.className = 'user-item';
                                item.innerHTML = `
                                    <img src="${info.avatar}" class="user-avatar" onerror="this.src='https://i.pravatar.cc/150?u=default'">
                                    <div class="user-info">
                                        <div class="user-name">${escapeHtml(info.username)}</div>
                                        <div class="user-status">Member</div>
                                    </div>
                                `;
                                container.appendChild(item);
                            });
                        } catch (e) { console.warn('renderGroupMembers failed', e); }
                    }

                    // show group info modal
                    function showGroupInfo(group) {
                        if (!group) return;
                        currentGroup = group;
                        const modal = document.getElementById('groupInfoModal');
                        const nameEl = document.getElementById('groupInfoName');
                        const metaEl = document.getElementById('groupInfoMeta');
                        const avatarBox = document.getElementById('groupInfoAvatar');
                        if (nameEl) nameEl.textContent = group.name || `Group ${group.id}`;
                        const members = group.members || [];
                        if (metaEl) metaEl.textContent = `${members.length} member${members.length===1?'':'s'}`;
                        if (avatarBox) {
                            avatarBox.style.backgroundImage = '';
                            avatarBox.textContent = (group.name || 'G').slice(0,1).toUpperCase();
                        }
                        renderGroupMembers(members);
                        modal.style.display = 'flex';
                    }

                    // wire modal close
                    try{
                        document.getElementById('viewGroupInfoAction')?.addEventListener('click', () => { showGroupInfo(currentGroup); });
                        document.getElementById('groupInfoClose')?.addEventListener('click', () => { document.getElementById('groupInfoModal').style.display='none'; });
                        document.getElementById('groupInfoCloseBtn')?.addEventListener('click', () => { document.getElementById('groupInfoModal').style.display='none'; });
                        // also wire header info button
                        document.getElementById('group-info-btn')?.addEventListener('click', () => { showGroupInfo(currentGroup); });
                    }catch(e){ console.warn('Group modal wiring failed', e); }
            // Add these new cases for friend system
            switch (data.type) {
                case 'friend_request_received':
                    // Add to friend requests
                    friendRequests.push({
                        id: data.request_id || `req_${Date.now()}`,
                        sender_id: data.from_id,
                        receiver_id: data.to_id,
                        status: 'pending',
                        timestamp: data.timestamp || new Date().toISOString()
                    });

                    saveFriendRequestsToStorage();
                    renderAllUsers(allUsers);
                    renderFriendRequestsList();
                    updateRequestCount();

                    showNotification(`Friend request from ${data.from}`, 'info');
                    break;

                case 'friend_request_accepted':
                    // Add to friends list
                    const newFriend = allUsers.find(u => u.user_id === data.user_id);
                    if (newFriend && !friends.some(f => f.user_id === data.user_id)) {
                        friends.push({
                            user_id: newFriend.user_id,
                            username: newFriend.username,
                            avatar: newFriend.avatar,
                            is_online: newFriend.is_online
                        });

                        saveFriendsToStorage();
                        renderAllUsers(allUsers);
                        renderFriendsList();

                        showNotification(`${data.username} accepted your friend request!`, 'success');
                    }
                    break;

                case 'user_status_update':
                    // Update user online status
                    const userIndex = allUsers.findIndex(u => u.user_id === data.user_id);
                    if (userIndex !== -1) {
                        allUsers[userIndex].is_online = data.is_online;
                        allUsers[userIndex].last_seen = data.last_seen;
                        renderAllUsers(allUsers);
                    }

                    // Update in friends list
                    const friendIndex = friends.findIndex(f => f.user_id === data.user_id);
                    if (friendIndex !== -1) {
                        friends[friendIndex].is_online = data.is_online;
                        friends[friendIndex].last_seen = data.last_seen;
                        renderFriendsList();
                    }
                    break;
            }
        }
        // Add CSS styles
        const friendSystemStyles = `
/* Tab styles */
.sidebar-tabs {
    display: flex;
    border-bottom: 1px solid #eee;
    margin: 10px 15px;
}

.tab-button {
    flex: 1;
    padding: 8px 5px;
    background: none;
    border: none;
    border-bottom: 2px solid transparent;
    cursor: pointer;
    font-size: 13px;
    color: #666;
    transition: all 0.2s;
}

.tab-button.active {
    color: #007bff;
    border-bottom-color: #007bff;
    font-weight: 500;
}

.tab-button:hover {
    color: #007bff;
}

/* User list styles */
.user-item {
    display: flex;
    align-items: center;
    padding: 12px 15px;
    border-bottom: 1px solid #f0f0f0;
    cursor: pointer;
    transition: background 0.2s;
}

.user-item:hover {
    background: #f9f9f9;
}

/* Highlight for incoming friend request */
.highlight-request {
    animation: highlight-pulse 2.5s ease-in-out 1;
    box-shadow: 0 4px 20px rgba(0,123,255,0.15);
    border-left: 4px solid #007bff;
}

@keyframes highlight-pulse {
    0% { background-color: rgba(0,123,255,0.08); }
    50% { background-color: rgba(0,123,255,0.14); }
    100% { background-color: transparent; }
}

.user-avatar {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    object-fit: cover;
    margin-right: 12px;
}

.user-info {
    flex: 1;
    min-width: 0;
}

.user-name {
    font-weight: 500;
    font-size: 14px;
    margin-bottom: 3px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}

.user-status {
    font-size: 12px;
    color: #666;
    display: flex;
    align-items: center;
}

.status-dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    margin-right: 6px;
}

.status-dot.online {
    background: #28a745;
}

.status-dot.offline {
    background: #ccc;
}

.status-badge {
    font-size: 10px;
    padding: 2px 6px;
    border-radius: 10px;
    margin-left: 8px;
    font-weight: 500;
}

.status-badge.friend {
    background: #d4edda;
    color: #155724;
}

.status-badge.request_sent {
    background: #fff3cd;
    color: #856404;
}

.status-badge.request_received {
    background: #cce5ff;
    color: #004085;
}

.user-actions {
    display: flex;
    gap: 5px;
}

.action-btn {
    padding: 6px 10px;
    border: none;
    border-radius: 4px;
    font-size: 12px;
    cursor: pointer;
    transition: all 0.2s;
    display: flex;
    align-items: center;
    gap: 4px;
}

.action-btn.add-btn {
    background: #007bff;
    color: white;
}

.action-btn.chat-btn {
    background: #28a745;
    color: white;
}

.action-btn.accept-btn {
    background: #28a745;
    color: white;
    padding: 8px;
}

.action-btn.reject-btn, 
.action-btn.remove-btn, 
.action-btn.cancel-btn {
    background: #dc3545;
    color: white;
    padding: 8px;
}

.action-btn:hover {
    opacity: 0.9;
}

.empty-state {
    text-align: center;
    padding: 40px 20px;
    color: #666;
    font-size: 14px;
}

.badge {
    background: #dc3545;
    color: white;
    font-size: 10px;
    padding: 2px 6px;
    border-radius: 10px;
    margin-left: 5px;
}
`;

        // Add styles to document
        const styleSheet = document.createElement('style');
        styleSheet.textContent = friendSystemStyles;
        document.head.appendChild(styleSheet);


        // Add forwarded indicator to message element (IMO-style)
        function addForwardedIndicator(messageElement, messageData) {
            if (messageData.is_forwarded) {
                const indicator = document.createElement('div');
                indicator.className = 'forwarded-indicator';
                indicator.innerHTML = '<i class="fas fa-share"></i> <span>Forwarded</span>';

                // Insert at the beginning of the message, after sender name if present
                const messageText = messageElement.querySelector('.message-text');
                if (messageText) {
                    messageText.insertBefore(indicator, messageText.firstChild);
                } else {
                    // For messages without message-text wrapper, insert at start
                    const firstChild = messageElement.firstChild;
                    if (firstChild) {
                        messageElement.insertBefore(indicator, firstChild);
                    } else {
                        messageElement.appendChild(indicator);
                    }
                }
            }
        }


        function handleIncomingGroupMessage(data) {
            const messageData = {
                id: data.id || data.message_id || 'msg_' + Date.now(),
                sender_id: data.from_id || data.sender_id,
                sender_username: data.from || data.sender_username,
                group_id: data.group_id,
                message: data.message,
                timestamp: data.timestamp || new Date().toISOString(),
                is_outgoing: false
            };

            const targetId = `group_${data.group_id}`;
            storeMessageInHistory(messageData, targetId);

            if (currentGroup && String(data.group_id) === String(currentGroup.id)) {
                addMessageToUI(messageData);
            } else {
                showNotificationWithSound(`New message in group`, 'info', true);
            }
        }


        // Handle incoming messages from Flask backend
        function handleIncomingMessage(data) {
            const messageData = {
                id: data.message_id || 'msg_' + Date.now(),
                sender_id: data.sender_id,
                sender_username: data.sender_username,
                receiver_id: currentUser.id || currentUser.user_id,
                message: data.message,
                is_forwarded: data.is_forwarded || false,  // Check if message is forwarded
                timestamp: data.timestamp || new Date().toISOString(),
                is_outgoing: false
            };

            // Blocked users check
            if (blockedUsers.includes(String(data.sender_id)) || blockedUsers.includes(String(data.sender_username))) {
                console.log('Blocked message from blocked user:', data.sender_username);
                showNotification(`Message blocked from ${data.sender_username}`, 'warning');
                return;
            }

            // 🛡️ SECURITY CHECK: Only accept messages from accepted friends
            const senderIsFriend = friends.some(friend =>
                String(friend.user_id) === String(data.sender_id) ||
                friend.username === data.sender_username
            );

            if (!senderIsFriend) {
                console.log('Blocked message from non-friend:', data.sender_username);
                showNotification(`Message blocked: ${data.sender_username} is not your friend`, 'warning');
                return; // 🚫 BLOCK THE MESSAGE
            }

            let targetId = data.sender_id;
            storeMessageInHistory(messageData, targetId);

            // STRICT VISIBILITY CHECK: Only add to UI if we are currently chatting with this SPECIFIC user
            // Ensure we are not in a group chat (currentPeer could be a group object in some implementations, though usually currentGroup handles that)
            // But to be safe, check !currentPeer.is_group if that property exists, or rely on the ID check.
            if (currentPeer && !currentPeer.is_group && String(data.sender_id) === String(currentPeer.user_id)) {
                addMessageToUI(messageData);
                // mark incoming message as received locally and send seen ack
                try {
                    if (wsConnection && wsConnection.readyState === WebSocket.OPEN) {
                        wsConnection.send(JSON.stringify({ type: 'message_seen', message_id: data.message_id }));
                    }
                } catch (err) { console.warn('Failed to send seen notification', err); }
            } else {
                // Notify if message is from someone else
                showNotificationWithSound(`New message from ${data.sender_username}`, 'info', true);
            }
        }

        // Handle incoming file messages from Flask backend
        function handleIncomingFileMessage(data) {
            // ignore messages that don't have sender info
            if (!data.sender_id && !data.sender_username) return;

            // Blocked users check
            if (blockedUsers.includes(String(data.sender_id)) || blockedUsers.includes(String(data.sender_username))) {
                console.log('Blocked file message from blocked user:', data.sender_username);
                showNotification(`File blocked from ${data.sender_username}`, 'warning');
                return;
            }

            // Only accept files from friends
            const senderIsFriend = friends.some(friend =>
                String(friend.user_id) === String(data.sender_id) ||
                friend.username === data.sender_username
            );

            if (!senderIsFriend) {
                console.log('Blocked file message from non-friend:', data.sender_username);
                showNotification(`File blocked: ${data.sender_username} is not your friend`, 'warning');
                return;
            }

            // Build normalized file message object
            const fileMessage = {
                id: data.client_id || data.message_id || 'file_' + Date.now(),
                type: 'file',
                file_name: data.file_name || data.filename || 'unknown',
                file_size: data.file_size || data.size || 0,
                file_type: data.file_type || data.mime || '',
                timestamp: data.timestamp || new Date().toISOString(),
                is_outgoing: false,
                sender_id: data.sender_id,
                sender_username: data.sender_username,
                sent: true,
                seen: false,
                deleted_request: false
            };

            // If the server included file bytes (data URL or base64) attach it so user can download
            if (data.file_data) {
                try { fileMessage.file_data = data.file_data; } catch (e) { }
            } else if (data.base64) {
                // if server used key 'base64'
                try { fileMessage.file_data = data.base64; } catch (e) { }
            }

            const targetId = data.sender_id;
            // If we have an optimistic local message with same client_id, replace it
            try {
                if (messageHistory[targetId] && messageHistory[targetId].length && fileMessage.id) {
                    const idx = messageHistory[targetId].findIndex(m => String(m.id) === String(fileMessage.id));
                    if (idx !== -1) {
                        messageHistory[targetId][idx] = fileMessage;
                    } else {
                        storeMessageInHistory(fileMessage, targetId);
                    }
                } else {
                    storeMessageInHistory(fileMessage, targetId);
                }
            } catch (e) { storeMessageInHistory(fileMessage, targetId); }
            // persist immediately if file_data present
            if (fileMessage.file_data) {
                try { localStorage.setItem(`msg_history_${targetId}`, JSON.stringify(messageHistory[targetId] || [])); } catch (e) { }
            }

            // STRICT VISIBILITY CHECK: Only add to UI if we are currently chatting with this specific user
            if (currentPeer && !currentPeer.is_group && String(data.sender_id) === String(currentPeer.user_id)) {
                addFileMessageToUI(fileMessage, false);
                try {
                    if (wsConnection && wsConnection.readyState === WebSocket.OPEN) {
                        wsConnection.send(JSON.stringify({ type: 'message_seen', message_id: data.message_id }));
                    }
                } catch (err) { console.warn('Failed to send seen notification for file', err); }
            } else {
                // Notification if not in chat
                showNotificationWithSound(`New file from ${data.sender_username}: ${fileMessage.file_name}`, 'info', true);
            }
        }

        // Handle incoming voice messages from Flask backend
        function handleIncomingVoiceMessage(data) {
            console.log('🎤 handleIncomingVoiceMessage called with data:', data);

            const voiceData = {
                id: data.message_id || 'voice_' + Date.now(),
                sender_id: data.sender_id,
                sender_username: data.sender_username,
                receiver_id: currentUser.id || currentUser.user_id,
                message: '[Voice Message]',
                type: 'voice',
                audio_data: data.audio_data,
                duration: data.duration || 0,
                timestamp: data.timestamp || new Date().toISOString(),
                is_outgoing: false
            };

            // Blocked users check
            if (blockedUsers.includes(String(data.sender_id)) || blockedUsers.includes(String(data.sender_username))) {
                console.log('Blocked voice message from blocked user:', data.sender_username);
                showNotification(`Voice message blocked from ${data.sender_username}`, 'warning');
                return;
            }

            // 🛡️ SECURITY CHECK: Only accept voice messages from accepted friends
            const senderIsFriend = friends.some(friend =>
                String(friend.user_id) === String(data.sender_id) ||
                friend.username === data.sender_username
            );

            if (!senderIsFriend) {
                console.log('Blocked voice message from non-friend:', data.sender_username);
                showNotification(`Voice message blocked: ${data.sender_username} is not your friend`, 'warning');
                return; // 🚫 BLOCK THE MESSAGE
            }

            let targetId = data.sender_id;
            storeMessageInHistory(voiceData, targetId);

            // STRICT VISIBILITY CHECK: Only add to UI if we are currently chatting with this SPECIFIC user
            if (currentPeer && !currentPeer.is_group && String(data.sender_id) === String(currentPeer.user_id)) {
                addVoiceMessageToUI(voiceData, false);
                // mark incoming message as received
                try {
                    if (wsConnection && wsConnection.readyState === WebSocket.OPEN) {
                        wsConnection.send(JSON.stringify({ type: 'message_seen', message_id: data.message_id }));
                    }
                } catch (err) { console.warn('Failed to send seen notification', err); }
            } else {
                // Notify if message is from someone else
                showNotificationWithSound(`New voice message from ${data.sender_username}`, 'info', true);
            }
        }

        // Add these handler functions:
        function handleIncomingFriendRequest(data) {
            const request = {
                id: data.request_id || `req_${Date.now()}`,
                from_id: data.from_id ?? data.from ?? data.sender_id,
                from_username: data.from || data.from_username,
                to_id: data.to_id ?? data.to ?? data.receiver_id,
                to_username: data.to || data.to_username,
                timestamp: data.timestamp || new Date().toISOString(),
                status: data.status || 'pending'
            };

            // Normalize canonical keys for runtime checks
            request.sender_id = request.sender_id ?? request.from_id;
            request.receiver_id = request.receiver_id ?? request.to_id;

            if (!Array.isArray(friendRequests)) friendRequests = [];
            const exists = friendRequests.some(r =>
                String(r.id) === String(request.id) ||
                (String(r.sender_id ?? r.from_id) === String(request.sender_id) && String(r.receiver_id ?? r.to_id) === String(request.receiver_id))
            );
            if (!exists) {
                friendRequests.push(request);
                try { saveFriendRequestsToStorage(); } catch (e) { try { saveFriendRequests(); } catch (_) {} }
            }

            try { renderFriendRequestsList(); } catch (e) { }
            try { updateRequestCount(); } catch (e) { }
            showNotificationWithSound(`New friend request from ${request.from_username || request.sender_id}`, 'info', true);

            // If this client is the intended receiver, ensure All Users tab is visible and highlight the requester
            const myId = String(currentUser?.id || currentUser?.user_id || '');
            if (String(request.receiver_id) === myId) {
                try { if (activeTab !== 'all-users') switchTab('all-users'); } catch (e) { }
                try { renderAllUsers(allUsers); } catch (e) { }
                try {
                    const el = document.querySelector(`#all-users-list .contact-item[data-user-id="${request.sender_id}"]`);
                    if (el) {
                        el.classList.add('highlight-request');
                        el.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        setTimeout(() => el.classList.remove('highlight-request'), 3000);
                    }
                } catch (e) { console.warn('Failed to highlight incoming request user', e); }
            } else {
                try { renderAllUsers(allUsers); } catch (e) { }
            }
        }

        function handleFriendRequestAccepted(data) {
            if (!Array.isArray(friendRequests)) friendRequests = [];
            const requestIndex = friendRequests.findIndex(req => String(req.id) === String(data.request_id));
            if (requestIndex !== -1) {
                const request = friendRequests[requestIndex];

                const friendUserId = request.receiver_id || request.to_id || data.user_id || data.to_id || data.from_id;
                const userObj = allUsers.find(u => String(u.user_id) === String(friendUserId)) || { user_id: friendUserId, username: request.to_username || data.to || data.from || 'Unknown' };

                const newFriend = {
                    user_id: userObj.user_id,
                    username: userObj.username,
                    is_online: userObj.is_online || true,
                    last_seen: userObj.last_seen || new Date().toISOString(),
                    friendship_date: new Date().toISOString()
                };

                friends.push(newFriend);
                saveFriends();

                friendRequests.splice(requestIndex, 1);
                saveFriendRequests();

                try { initializeFriendChatHistory(userObj.user_id); } catch (e) {}

                showNotification(`${userObj.username} accepted your friend request! You can now chat.`, 'success');

                try { renderFriendsInSidebar(friends); } catch (e) {}
            }
        }

        function handleFriendRequestRejected(data) {
            if (!Array.isArray(friendRequests)) friendRequests = [];
            const requestIndex = friendRequests.findIndex(req => String(req.id) === String(data.request_id));
            if (requestIndex !== -1) {
                const req = friendRequests[requestIndex];
                friendRequests.splice(requestIndex, 1);
                saveFriendRequests();
                showNotification(`Friend request to ${req.receiver_id || data.to || 'user'} was rejected`, 'info');
            }
        }
        function handleDeliveryAck(data) {
            // data: { type: 'delivery_ack', client_id, message_id, to_id }
            console.log('🔁 Delivery ack received', data);
            const clientId = data.client_id;
            const realId = String(data.message_id);
            const targetId = data.to_id || data.receiver_id || (currentPeer && currentPeer.user_id);

            // Update messageHistory and localStorage
            if (messageHistory[targetId]) {
                const msg = messageHistory[targetId].find(m => m.id === clientId);
                if (msg) {
                    msg.id = realId;
                    msg.sent = true;
                    // persist
                    try { localStorage.setItem(`msg_history_${targetId}`, JSON.stringify(messageHistory[targetId])); } catch (e) { }
                    // If there was a pending delete request for this message (queued while temp), send delete now
                    if (msg.deleted_request && wsConnection && wsConnection.readyState === WebSocket.OPEN) {
                        try {
                            wsConnection.send(JSON.stringify({ type: 'delete_message', message_id: Number(realId) }));
                            // clear the flag
                            msg.deleted_request = false;
                        } catch (err) {
                            console.warn('Failed to send queued delete after ack', err);
                        }
                    }
                }
            }

            // Update DOM element data attribute
            const el = chatMessages.querySelector(`[data-msg-id="${clientId}"]`);
            if (el) el.dataset.msgId = realId;
            // Update DOM status: mark outbound message as delivered (one tick)
            updateMessageStatusDOM(realId, 'delivered');
        }

        function handleMessageDeleted(data) {
            // data: { type:'message_deleted', message_id, by }
            const mid = String(data.message_id);
            console.log('🗑️ Message deleted event received for', mid);

            // Remove from UI
            const el = chatMessages.querySelector(`[data-msg-id="${mid}"]`);
            if (el && el.parentNode) el.parentNode.removeChild(el);

            // Remove from messageHistory & persist
            Object.keys(messageHistory).forEach(targetId => {
                const arr = messageHistory[targetId];
                const idx = arr.findIndex(m => String(m.id) === mid);
                if (idx !== -1) {
                    arr.splice(idx, 1);
                    try { localStorage.setItem(`msg_history_${targetId}`, JSON.stringify(arr)); } catch (e) { }
                }
            });

            showNotification('A message was deleted', 'info');
        }

        // Update message status DOM (pending | delivered | seen)
        function updateMessageStatusDOM(msgId, status) {
            if (!msgId) return;
            const el = chatMessages.querySelector(`[data-msg-id="${msgId}"]`);
            if (!el) return;
            const statusEl = el.querySelector('.msg-status');
            if (!statusEl) return;
            statusEl.classList.remove('pending', 'delivered', 'seen');
            if (status === 'delivered') {
                statusEl.classList.add('delivered');
                statusEl.title = 'Delivered';
            } else if (status === 'seen') {
                statusEl.classList.add('seen');
                statusEl.title = 'Seen';
            } else {
                statusEl.classList.add('pending');
                statusEl.title = 'Pending';
            }
        }

        // Delete message locally (remove from UI and local storage)
        function deleteLocalMessage(msgId, targetId) {
            if (!msgId) return;
            const el = chatMessages.querySelector(`[data-msg-id="${msgId}"]`);
            if (el && el.parentNode) el.parentNode.removeChild(el);

            if (messageHistory[targetId]) {
                const idx = messageHistory[targetId].findIndex(m => String(m.id) === String(msgId));
                if (idx !== -1) {
                    messageHistory[targetId].splice(idx, 1);
                    try { localStorage.setItem(`msg_history_${targetId}`, JSON.stringify(messageHistory[targetId])); } catch (e) { }
                }
            }
            showNotification('Message removed locally', 'success');
        }

        // Request delete for everyone (requires a real message id assigned by server)
        function deleteMessageForEveryone(msgId, targetId) {
            if (!msgId) return showNotification('Cannot delete: unknown message id', 'error');
            // If msgId is a temp id (starts with 'temp_'), queue the delete for when server assigns real id
            if (String(msgId).startsWith('temp_')) {
                // mark locally as deleted request and remove from UI
                if (messageHistory[targetId]) {
                    const m = messageHistory[targetId].find(m => String(m.id) === String(msgId));
                    if (m) {
                        m.deleted_request = true;
                        try { localStorage.setItem(`msg_history_${targetId}`, JSON.stringify(messageHistory[targetId])); } catch (e) { }
                    }
                }
                deleteLocalMessage(msgId, targetId);
                return showNotification('Delete queued: will be sent when message is delivered', 'info');
            }

            // Optimistically remove locally
            deleteLocalMessage(msgId, targetId);

            // Ask server to delete
            if (wsConnection && wsConnection.readyState === WebSocket.OPEN) {
                try {
                    wsConnection.send(JSON.stringify({ type: 'delete_message', message_id: Number(msgId) }));
                } catch (err) {
                    console.error('Failed to send delete request:', err);
                    showNotification('Delete request failed', 'error');
                }
            } else {
                // If offline, delete locally and mark deletion request to be retried on reconnect
                showNotification('Offline: message deleted locally. Server deletion will be attempted when reconnected.', 'info');
                // mark as deleted in history so flush won't resend
                if (messageHistory[targetId]) {
                    const m = messageHistory[targetId].find(m => String(m.id) === String(msgId));
                    if (m) m.deleted_request = true;
                    try { localStorage.setItem(`msg_history_${targetId}`, JSON.stringify(messageHistory[targetId])); } catch (e) { }
                }
            }
        }

        // Call event handlers
        acceptCallBtn.addEventListener('click', async () => {
            incomingCallAlert.classList.remove('active');

            try {
                const callType = window.currentCaller.call_type;
                localStream = await navigator.mediaDevices.getUserMedia({
                    video: callType === 'video',
                    audio: true
                });

                localVideo.srcObject = localStream;
                isInCall = true;
                callContainer.classList.add('active');
                remoteUserLabel.textContent = window.currentCaller.username;

                // Prepare peer connection to receive incoming offer
                rtcPeerConnection = createPeerConnection(window.currentCaller.username);
                if (localStream) {
                    localStream.getTracks().forEach(t => rtcPeerConnection.addTrack(t, localStream));
                }

                if (wsConnection && wsConnection.readyState === WebSocket.OPEN) {
                    const response = {
                        type: 'call_accepted',
                        from: currentUser.username,
                        from_id: currentUser.id,
                        to: window.currentCaller.username,
                        to_id: window.currentCaller.user_id
                    };
                    try {
                        wsConnection.send(JSON.stringify(response));
                    } catch (err) {
                        console.error('Failed to send call_accepted signal:', err);
                        showNotification(`Failed to accept call: ${err.message || err}`, 'error');
                    }
                }

            } catch (error) {
                console.error('Error accepting call:', error);
                showNotification('Failed to access camera/microphone', 'error');
            }
        });

        rejectCallBtn.addEventListener('click', () => {
            incomingCallAlert.classList.remove('active');

            if (wsConnection && wsConnection.readyState === WebSocket.OPEN) {
                const response = {
                    type: 'call_rejected',
                    from: currentUser.username,
                    from_id: currentUser.id,
                    to: window.currentCaller.username,
                    to_id: window.currentCaller.user_id
                };
                wsConnection.send(JSON.stringify(response));
            }
            showNotification('Call rejected', 'info');
        });

        // Add event listeners for call controls
        function addEventListeners() {
            // Message sending
            sendBtn.addEventListener('click', sendMessage);
            messageInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') sendMessage();
            });

            // Sidebar tab switching (Friends / All Users)
            document.querySelectorAll('.sidebar-tabs .tab-button').forEach(btn => {
                btn.addEventListener('click', function () {
                    const tabName = this.dataset.tab;
                    console.log('🔄 Switching to tab:', tabName);

                    // Update active tab button
                    document.querySelectorAll('.sidebar-tabs .tab-button').forEach(b => {
                        b.classList.remove('active');
                    });
                    this.classList.add('active');

                    // Show/hide corresponding content
                    if (tabName === 'friends') {
                        document.getElementById('peer-list').style.display = '';
                        document.getElementById('groups-container').style.display = 'none';
                        document.getElementById('all-users-container').style.display = 'none';
                    } else if (tabName === 'groups') {
                        document.getElementById('peer-list').style.display = 'none';
                        document.getElementById('groups-container').style.display = '';
                        document.getElementById('all-users-container').style.display = 'none';

                        // Render groups when tab is activated
                        console.log('👥 Groups tab activated, rendering groups...');
                        renderGroupsList();
                    } else if (tabName === 'all-users') {
                        document.getElementById('peer-list').style.display = 'none';
                        document.getElementById('groups-container').style.display = 'none';
                        document.getElementById('all-users-container').style.display = '';
                        console.log('👥 All Users tab activated, current allUsers:', allUsers);

                        // If we don't have users yet, request them
                        if (!allUsers || allUsers.length === 0) {
                            console.log('📡 No users loaded, requesting from server...');
                            requestUsersList();
                        } else {
                            console.log('📋 Rendering existing users:', allUsers.length);
                            renderAllUsers(allUsers);
                        }
                    }
                });
            });

            // Discover peers button
            const discoverPeersBtn = document.getElementById('discover-peers');
            if (discoverPeersBtn) {
                discoverPeersBtn.addEventListener('click', function () {
                    requestUsersList();
                });
            }

            // All other event listeners...
            document.getElementById('audio-call-btn')?.addEventListener('click', startAudioCall);
            document.getElementById('video-call-btn')?.addEventListener('click', startVideoCall);
            fileBtn.addEventListener('click', () => fileInput.click());
            fileInput.addEventListener('change', handleFileSelect);
            endCallBtn.addEventListener('click', endCall);
            muteBtn.addEventListener('click', toggleMute);
            videoBtn.addEventListener('click', toggleVideo);

            document.getElementById('back-btn')?.addEventListener('click', function () {
                chatPage.classList.add('hidden');
                emptyView.classList.remove('hidden');
                currentPeer = null;
                currentGroup = null;
            });
        }

        // Switch between tabs (deprecated modal version)
        function switchTab(tabName) {
            activeTab = tabName;

            // Update active tab button
            document.querySelectorAll('.tab-button').forEach(btn => {
                btn.classList.remove('active');
            });
            document.getElementById(`tab-${tabName}`)?.classList.add('active');

            // Show/hide containers
            document.getElementById('all-users-container')?.classList.add('hidden');
            document.getElementById('friends-container')?.classList.add('hidden');
            document.getElementById('requests-container')?.classList.add('hidden');

            document.getElementById(`${tabName}-container`)?.classList.remove('hidden');

            // Load data if needed
            if (tabName === 'all-users') {
                renderAllUsers(allUsers);
            } else if (tabName === 'friends') {
                renderFriendsList();
            } else if (tabName === 'friend-requests') {
                renderFriendRequestsList();
            }
        }

        // Request users list from backend via WebSocket
        function requestUsersList() {
            console.log('🔌 requestUsersList() called');
            console.log('🔌 WebSocket state:', wsConnection?.readyState, '(1 = OPEN)');
            if (wsConnection && wsConnection.readyState === WebSocket.OPEN) {
                console.log('📡 Requesting user list from backend via WebSocket...');
                wsConnection.send(JSON.stringify({ type: 'get_users' }));
                showNotification('Refreshing user list...', 'info');
            } else {
                console.warn('⚠️ WebSocket not connected, falling back to REST API');
                console.warn('⚠️ wsConnection:', wsConnection);
                showNotification('Falling back to REST API to fetch users', 'info');
                fetchUsersViaAPI();
            }
        }

        // Fetch users via REST API as a fallback when WebSocket is unavailable
        async function fetchUsersViaAPI() {
            try {
                const url = `${API_URL}/users/all`;
                console.log('🌐 Fetching users via REST:', url);
                const resp = await fetch(url, { credentials: 'include' });
                if (!resp.ok) {
                    throw new Error(`HTTP ${resp.status}`);
                }
                const data = await resp.json();
                if (data && data.success && Array.isArray(data.users)) {
                    // Normalize to client expected shape
                    allUsers = data.users.map(u => ({
                        user_id: u.user_id || u.id,
                        username: u.username,
                        avatar: u.avatar || u.avatar_url || `https://i.pravatar.cc/150?u=${u.username}`,
                        is_online: u.is_online || false,
                        last_seen: u.last_seen || null
                    }));
                    console.log('📋 allUsers updated from REST:', allUsers.length);
                    renderAllUsers(allUsers);
                    showNotification('User list loaded via REST API', 'success');
                } else if (data && Array.isArray(data.users)) {
                    // Some backends may return array directly
                    allUsers = data.users.map(u => ({
                        user_id: u.user_id || u.id,
                        username: u.username,
                        avatar: u.avatar || u.avatar_url || `https://i.pravatar.cc/150?u=${u.username}`,
                        is_online: u.is_online || false,
                        last_seen: u.last_seen || null
                    }));
                    renderAllUsers(allUsers);
                    showNotification('User list loaded via REST API', 'success');
                } else {
                    console.warn('No users returned from REST API', data);
                    showNotification('No users found via REST', 'warning');
                }
            } catch (err) {
                console.error('Error fetching users via REST API:', err);
                showNotification('Failed to fetch users via REST API', 'error');
            }
        }

        // DEPRECATED: Load real users from your Flask API (now using WebSocket instead)
        async function loadUsersFromAPI() {
            console.warn('loadUsersFromAPI is deprecated, using requestUsersList instead');
            requestUsersList();
        }

        // UPDATED: Peer list handling for your Flask backend
        function updatePeersList(peersData) {
            console.log('👥 Updating peers list with:', peersData);

            // Transform the data to match what your UI expects
            const transformedPeers = peersData.map(peer => ({
                user_id: peer.user_id || peer.id,
                peer_id: peer.user_id || peer.id,
                username: peer.username,
                is_online: peer.is_online,
                last_seen: peer.last_seen
            }));

            peers = transformedPeers;

            // Update online status and last_seen in allUsers array
            peersData.forEach(peerUpdate => {
                const userId = peerUpdate.user_id || peerUpdate.id;

                // Update in allUsers
                const userIndex = allUsers.findIndex(u => u.user_id === userId);
                if (userIndex !== -1) {
                    allUsers[userIndex].is_online = peerUpdate.is_online;
                    allUsers[userIndex].last_seen = peerUpdate.last_seen;
                }

                // Update in friends
                const friendIndex = friends.findIndex(f => f.user_id === userId);
                if (friendIndex !== -1) {
                    friends[friendIndex].is_online = peerUpdate.is_online;
                    friends[friendIndex].last_seen = peerUpdate.last_seen;
                }
            });

            // Re-render if currently viewing
            renderPeers(transformedPeers);
            renderFriendsInSidebar(friends);

            // Update chat header if currently chatting with someone whose status changed
            if (currentPeer) {
                const updated = peersData.find(p => (p.user_id || p.id) === currentPeer.user_id);
                if (updated) {
                    currentPeer.is_online = updated.is_online;
                    currentPeer.last_seen = updated.last_seen;
                    chatPresence.textContent = updated.is_online ? 'Online' : `Last seen: ${formatLastSeen(updated.last_seen)}`;
                }
            }
        }

        // Format last seen timestamp
        function formatLastSeen(timestamp) {
            if (!timestamp) return 'Unknown';
            const date = new Date(timestamp);
            const now = new Date();
            const diffMs = now - date;
            const diffMins = Math.floor(diffMs / 60000);
            const diffHours = Math.floor(diffMs / 3600000);

            if (diffMins < 1) return 'just now';
            if (diffMins < 60) return `${diffMins} minute${diffMins > 1 ? 's' : ''} ago`;
            if (diffHours < 24) return `${diffHours} hour${diffHours > 1 ? 's' : ''} ago`;
            return date.toLocaleString();
        }

        function loadDefaultPeers() {
            const defaultPeers = [
                { user_idc: '1', peer_id: '1', username: 'Alice', is_online: true },
                { user_id: '2', peer_id: '2', username: 'Bob', is_online: false },
                { user_id: '3', peer_id: '3', username: 'Charlie', is_online: true },
                { user_id: '4', peer_id: '4', username: 'Diana', is_online: true }
            ];
            peers = defaultPeers;
            renderPeers(defaultPeers);
        }

        // Render all users in the all-users tab
        function renderAllUsers(users) {
            console.log('🔄 renderAllUsers called with:', users);
            const container = document.getElementById('all-users-list');
            console.log('🔄 Container found:', container);

            if (!container) {
                console.warn('❌ all-users-list container not found');
                return;
            }

            if (!users || users.length === 0) {
                console.log('⚠️ No users to render');
                container.innerHTML = '<li class="empty-state">No users found</li>';
                return;
            }

            // Filter out current user
            const currentUserId = currentUser?.id || currentUser?.user_id;
            const filteredUsers = users.filter(user => user.user_id !== currentUserId);
            console.log('🔄 Filtered users (excluding current user):', filteredUsers.length);

            container.innerHTML = filteredUsers.map(user => {
                // Determine friend status
                let status = 'not_friend';
                let statusText = '';
                let actionButtons = '';

                const isFriend = friends.some(f => String(f.user_id) === String(user.user_id));

                // helpers to support multiple possible request shapes (legacy: from_id/to_id)
                const senderOf = (req) => String(req.sender_id ?? req.from_id ?? req.from ?? req.user_id ?? '');
                const receiverOf = (req) => String(req.receiver_id ?? req.to_id ?? req.to ?? req.target_id ?? '');
                const currentIdStr = String(currentUserId);
                const userIdStr = String(user.user_id);

                const hasSentRequest = friendRequests.some(r =>
                    senderOf(r) === currentIdStr && receiverOf(r) === userIdStr && (r.status === 'pending' || !r.status)
                );
                const hasReceivedRequest = friendRequests.some(r =>
                    receiverOf(r) === currentIdStr && senderOf(r) === userIdStr && (r.status === 'pending' || !r.status)
                );

                if (isFriend) {
                    status = 'friend';
                    statusText = '✓ Friend';
                    actionButtons = `<button class="btn-small btn-chat" data-user-id="${user.user_id}">Chat</button>`;
                } else if (hasSentRequest) {
                    status = 'request_sent';
                    statusText = 'Request Sent';
                    actionButtons = `<button class="btn-small btn-cancel" data-user-id="${user.user_id}">Cancel</button>`;
                } else if (hasReceivedRequest) {
                    status = 'request_received';
                    statusText = 'Request Received';
                    actionButtons = `
                        <button class="btn-small btn-accept" data-user-id="${user.user_id}">Accept</button>
                        <button class="btn-small btn-reject" data-user-id="${user.user_id}">Reject</button>
                    `;
                } else {
                    actionButtons = `<button class="btn-small btn-add" data-user-id="${user.user_id}">Add Friend</button>`;
                }

                return `
            <li class="contact-item user-item" data-user-id="${user.user_id}">
                <img src="${user.avatar || `https://i.pravatar.cc/150?u=${user.username}`}" alt="${user.username}">
                <div class="meta">
                    <div class="peer-name">${user.username} ${statusText ? `<span class="status-badge ${status}">${statusText}</span>` : ''}</div>
                    <div class="peer-sub">
                        <span class="status-dot ${user.is_online ? 'online' : 'offline'}"></span>
                        ${user.is_online ? 'Online' : (user.last_seen ? formatLastSeen(user.last_seen) : 'Offline')}
                    </div>
                </div>
                <div class="user-actions" onclick="event.stopPropagation()">
                    ${actionButtons}
                </div>
            </li>
        `;
            }).join('');

            // Add event listeners to action buttons
            addAllUsersActionListeners();
        }

        // Add event listeners for all users action buttons
        function addAllUsersActionListeners() {
            // Chat button
            document.querySelectorAll('#all-users-list .btn-chat').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const userId = btn.dataset.userId;
                    const user = allUsers.find(u => u.user_id === userId);
                    if (user) {
                        const friend = friends.find(f => f.user_id === userId);
                        if (friend) selectPeer(e, friend);
                    }
                });
            });

            // Add friend button
            document.querySelectorAll('#all-users-list .btn-add').forEach(btn => {
                btn.addEventListener('click', async (e) => {
                    e.stopPropagation();
                    const userId = btn.dataset.userId;
                    await sendFriendRequest(userId);
                });
            });

            // Accept button
            document.querySelectorAll('#all-users-list .btn-accept').forEach(btn => {
                btn.addEventListener('click', async (e) => {
                    e.stopPropagation();
                    const userId = btn.dataset.userId;
                    await acceptFriendRequest(userId);
                });
            });

            // Reject button
            document.querySelectorAll('#all-users-list .btn-reject').forEach(btn => {
                btn.addEventListener('click', async (e) => {
                    e.stopPropagation();
                    const userId = btn.dataset.userId;
                    await rejectFriendRequest(userId);
                });
            });

            // Cancel button
            document.querySelectorAll('#all-users-list .btn-cancel').forEach(btn => {
                btn.addEventListener('click', async (e) => {
                    e.stopPropagation();
                    const userId = btn.dataset.userId;
                    await cancelFriendRequest(userId);
                });
            });
        }

        function renderFriendsInSidebar(friendsList) {
            // Preserve existing group items
            const existingGroupItems = Array.from(peerList.querySelectorAll('.group-item'));
            peerList.innerHTML = '';
            existingGroupItems.forEach(item => peerList.appendChild(item));

            if (friendsList.length === 0) {
                peerList.innerHTML = `
            <div class="no-friends-message">
                <i class="fas fa-user-friends"></i>
                <p>No friends yet</p>
                <small>Send friend requests to start chatting</small>
            </div>
        `;
                return;
            }

            friendsList.forEach((friend) => {
                const friendItem = document.createElement('li');
                friendItem.className = 'contact-item';
                friendItem.dataset.peerId = friend.peer_id;
                friendItem.dataset.userId = friend.user_id;
                friendItem.dataset.isFriend = 'true'; // Mark as friend

                const statusText = friend.is_online ? 'Online' : 'Offline';
                const lastSeen = friend.last_seen ? new Date(friend.last_seen).toLocaleTimeString() : 'Unknown';

                const isBlocked = blockedUsers.includes(String(friend.user_id));
                friendItem.innerHTML = `
            <img src="https://i.pravatar.cc/150?u=${friend.username}" alt="${friend.username}">
            <div class="meta">
                <div class="peer-name">${friend.username} ${isBlocked ? '<span class="status-badge request_sent">Blocked</span>' : '<span class="friend-badge">👤</span>'}</div>
                <div class="peer-sub">${statusText} • Last seen: ${lastSeen}</div>
            </div>
        `;

                // Click selects peer
                friendItem.addEventListener('click', (e) => selectPeer(e, friend));

                // Options button (appears only on tap) to manage friend actions
                const opts = document.createElement('button');
                opts.className = 'action-btn';
                opts.style.marginLeft = '8px';
                opts.title = 'Options';
                opts.innerHTML = '<i class="fas fa-ellipsis-v"></i>';
                opts.addEventListener('click', (ev) => {
                    ev.stopPropagation();
                    openFriendMenu(friend, friendItem);
                });
                friendItem.appendChild(opts);
                peerList.appendChild(friendItem);
            });
        }

        // Open friend management menu (tap-only) next to the friend item
        function openFriendMenu(user, anchorEl) {
            // remove existing menus
            document.querySelectorAll('.friend-menu').forEach(m => m.remove());

            const menu = document.createElement('div');
            menu.className = 'friend-menu';
            menu.style.cssText = 'position:absolute; right:10px; background:#fff; border:1px solid #ddd; padding:8px; border-radius:6px; z-index:1001; box-shadow:0 8px 24px rgba(0,0,0,0.12);';

            // Delete/Remove
            const del = document.createElement('button');
            del.className = 'btn-small';
            del.textContent = 'Delete Friend';
            del.addEventListener('click', async (ev) => {
                ev.stopPropagation();
                if (confirm(`Remove ${user.username} from friends?`)) {
                    await removeFriend(user.user_id);
                }
                menu.remove();
            });
            menu.appendChild(del);

            // Block or Unblock depending on state
            const isBlocked = blockedUsers.includes(String(user.user_id));
            const blk = document.createElement('button');
            blk.className = 'btn-small';
            blk.style.marginLeft = '6px';
            blk.textContent = isBlocked ? 'Unblock' : 'Block';
            blk.addEventListener('click', (ev) => {
                ev.stopPropagation();
                if (isBlocked) unblockUser(user.user_id, user.username);
                else blockUser(user.user_id, user.username);
                menu.remove();
            });
            menu.appendChild(blk);

            // Append menu to anchor and position it
            anchorEl.style.position = 'relative';
            anchorEl.appendChild(menu);

            // Close on outside click
            setTimeout(() => {
                const closer = (e) => {
                    if (!menu.contains(e.target)) menu.remove();
                };
                document.addEventListener('click', closer, { once: true });
            }, 10);
        }

        function blockUser(userId, username) {
            try {
                const id = String(userId);
                if (!blockedUsers.includes(id)) {
                    blockedUsers.push(id);
                    saveBlockedUsersToStorage();
                    showNotification(`${username} blocked`, 'info');
                    // Optionally update UI: mark friend as blocked
                    renderFriendsInSidebar(friends);
                }
            } catch (e) { console.warn('blockUser failed', e); }
        }

        function unblockUser(userId, username) {
            try {
                const id = String(userId);
                const idx = blockedUsers.indexOf(id);
                if (idx !== -1) {
                    blockedUsers.splice(idx, 1);
                    saveBlockedUsersToStorage();
                    showNotification(`${username} unblocked`, 'success');
                    renderFriendsInSidebar(friends);
                }
            } catch (e) { console.warn('unblockUser failed', e); }
        }
        // Get action buttons based on user status
        function getUserActionButtons(user, status) {
            const currentUserId = currentUser?.id || currentUser?.user_id;

            switch (status) {
                case 'friend':
                    return `
                <button class="action-btn chat-btn" data-action="chat" data-user-id="${user.user_id}">
                    <i class="fas fa-comment"></i> Chat
                </button>
                <button class="action-btn remove-btn" data-action="remove" data-user-id="${user.user_id}">
                    <i class="fas fa-user-times"></i>
                </button>
            `;
                case 'request_sent':
                    return `
                <button class="action-btn cancel-btn" data-action="cancel" data-user-id="${user.user_id}">
                    <i class="fas fa-clock"></i> Cancel
                </button>
            `;
                case 'request_received':
                    return `
                <button class="action-btn accept-btn" data-action="accept" data-user-id="${user.user_id}">
                    <i class="fas fa-check"></i> Accept
                </button>
                <button class="action-btn reject-btn" data-action="reject" data-user-id="${user.user_id}">
                    <i class="fas fa-times"></i> Reject
                </button>
            `;
                default:
                    return `
                <button class="action-btn add-btn" data-action="add" data-user-id="${user.user_id}">
                    <i class="fas fa-user-plus"></i> Add
                </button>
            `;
            }
        }

        // Search helper: render contact search results in sidebar (covers friends + allUsers)
        function renderContactSearchResults(query) {
            const q = String(query || '').trim().toLowerCase();
            if (!q) {
                // empty query -> show normal friends sidebar
                renderFriendsInSidebar(friends);
                return;
            }

            // Combine friends and allUsers, dedupe by user_id
            const map = new Map();
            friends.forEach(f => map.set(String(f.user_id), { username: f.username, user_id: f.user_id, avatar: f.avatar, is_online: f.is_online, _isFriend: true }));
            allUsers.forEach(u => {
                const id = String(u.user_id);
                if (!map.has(id) && (u.user_id !== (currentUser?.id || currentUser?.user_id))) {
                    map.set(id, { username: u.username, user_id: u.user_id, avatar: u.avatar, is_online: u.is_online, _isFriend: false });
                }
            });

            const combined = Array.from(map.values());

            const results = combined.filter(u => (u.username || '').toLowerCase().includes(q));

            // Render in sidebar
            peerList.innerHTML = '';
            if (!results.length) {
                peerList.innerHTML = '<li class="empty-state">No contacts found</li>';
                return;
            }

            results.forEach(u => {
                const li = document.createElement('li');
                li.className = 'contact-item';
                li.dataset.userId = u.user_id;
                li.innerHTML = `
                    <img src="${u.avatar || `https://i.pravatar.cc/150?u=${u.username}`}" alt="${u.username}">
                    <div class="meta">
                        <div class="peer-name">${u.username}${u._isFriend ? ' <span class="friend-badge">👤</span>' : ''}</div>
                        <div class="peer-sub"><span class="status-dot ${u.is_online ? 'online' : 'offline'}"></span> ${u.is_online ? 'Online' : ''}</div>
                    </div>
                `;
                li.addEventListener('click', (e) => {
                    // If friend object exists, pass it through; otherwise create minimal peer
                    const friendObj = friends.find(f => String(f.user_id) === String(u.user_id));
                    if (friendObj) selectPeer(e, friendObj);
                    else selectPeer(e, { username: u.username, user_id: u.user_id });
                });
                // Add options button for search results too
                const opts = document.createElement('button');
                opts.className = 'action-btn';
                opts.style.marginLeft = '8px';
                opts.title = 'Options';
                opts.innerHTML = '<i class="fas fa-ellipsis-v"></i>';
                opts.addEventListener('click', (ev) => {
                    ev.stopPropagation();
                    const friendObj = friends.find(f => String(f.user_id) === String(u.user_id));
                    openFriendMenu(friendObj || { user_id: u.user_id, username: u.username }, li);
                });
                li.appendChild(opts);
                peerList.appendChild(li);
            });
        }
        // Handle user actions
        async function handleUserAction(action, user) {
            switch (action) {
                case 'add':
                    await sendFriendRequest(user.user_id);
                    break;
                case 'accept':
                    await acceptFriendRequest(user.user_id);
                    break;
                case 'reject':
                    await rejectFriendRequest(user.user_id);
                    break;
                case 'cancel':
                    await cancelFriendRequest(user.user_id);
                    break;
                case 'remove':
                    if (confirm(`Remove ${user.username} from friends?`)) {
                        await removeFriend(user.user_id);
                    }
                    break;
                case 'block':
                    if (!blockedUsers.includes(String(user.user_id))) {
                        blockUser(user.user_id, user.username);
                    }
                    break;
                case 'unblock':
                    if (blockedUsers.includes(String(user.user_id))) {
                        unblockUser(user.user_id, user.username);
                    }
                    break;
                case 'chat':
                    await startChatWithFriend(user);
                    break;
            }
        }


        // Add event listeners to user action buttons
        function addUserActionListeners() {
            document.querySelectorAll('.user-item .action-btn').forEach(button => {
                button.addEventListener('click', async (e) => {
                    e.stopPropagation();
                    const action = button.dataset.action;
                    const userId = button.dataset.userId;
                    const user = allUsers.find(u => u.user_id === userId);

                    if (!user) return;

                    await handleUserAction(action, user);
                });
            });

            // Click on user item to view details
            document.querySelectorAll('.user-item').forEach(item => {
                item.addEventListener('click', () => {
                    const userId = item.dataset.userId;
                    const user = allUsers.find(u => u.user_id === userId);
                    if (user) {
                        viewUserProfile(user);
                    }
                });
            });
        }
        function selectPeer(e, peer) {
            document.querySelectorAll('.contact-item').forEach(item => {
                item.classList.remove('active');
            });
            if (e && e.currentTarget) e.currentTarget.classList.add('active');

            currentPeer = peer;
            currentGroup = null;
            chatWith.textContent = peer.username;
            chatPresence.textContent = peer.is_online ? 'Online' : 'Offline';
            chatAvatar.src = `https://i.pravatar.cc/150?u=${peer.username}`;

            emptyView.classList.add('hidden');
            chatPage.classList.remove('hidden');

            loadMessagesForPeer(peer.user_id);
        }

        async function loadMessagesForPeer(peerId) {
            chatMessages.innerHTML = '';

            const welcomeMsg = document.createElement('div');
            welcomeMsg.className = 'message incoming';
            welcomeMsg.innerHTML = `
                <div class="message-text">💬 Start chatting with ${currentPeer?.username || 'this peer'}!</div>
                <div class="message-time">${new Date().toLocaleTimeString()}</div>
            `;
            chatMessages.appendChild(welcomeMsg);

            // Load persisted history (if any) then render local messages
            loadMessageHistoryFor(peerId);
            const myId = currentUser.id || currentUser.user_id;

            // Build a set to avoid rendering duplicates (id or client-generated id)
            const renderedIds = new Set();

            // Only show messages where sender/receiver pair matches (me <-> peer)
            const localPeerMessages = (messageHistory[peerId] || []).filter(message => {
                return (
                    (Number(message.sender_id) === Number(myId) && Number(message.receiver_id) === Number(peerId)) ||
                    (Number(message.sender_id) === Number(peerId) && Number(message.receiver_id) === Number(myId))
                );
            });

            // Ensure messages are in chronological order (oldest -> newest)
            localPeerMessages.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
            localPeerMessages.forEach(message => {
                const idKey = message.id || message.message_id || message.client_id;
                if (idKey && renderedIds.has(idKey)) return;
                if (idKey) renderedIds.add(idKey);

                if (message.message_type === 'file' || message.type === 'file') {
                    addFileMessageToUI(message, message.is_outgoing || false);
                } else {
                    addMessageToUI(message);
                }
            });

            // Fetch authoritative server-side conversation (ensures no leakage from localStorage)
            try {
                const resp = await fetch(`${API_URL}/chat/messages/${peerId}`, {
                    method: 'GET',
                    credentials: 'include',
                    headers: { 'Accept': 'application/json' }
                });

                if (resp.ok) {
                    const data = await resp.json();
                    if (data && data.success && Array.isArray(data.messages)) {
                        // Server returns newest first; reverse to chronological
                        const serverMessages = data.messages.slice().reverse();
                        serverMessages.forEach(message => {
                            // Defensive filter: only allow two-party messages
                            if (!(
                                (Number(message.sender_id) === Number(myId) && Number(message.receiver_id) === Number(peerId)) ||
                                (Number(message.sender_id) === Number(peerId) && Number(message.receiver_id) === Number(myId))
                            )) return;

                            const idKey = message.id || message.message_id;
                            if (idKey && renderedIds.has(idKey)) return;
                            if (idKey) renderedIds.add(idKey);

                            // Normalize shape expected by UI helpers
                            const normalized = {
                                id: message.id || message.message_id,
                                message_id: message.id || message.message_id,
                                sender_id: message.sender_id,
                                receiver_id: message.receiver_id,
                                message: message.message,
                                message_type: message.message_type || 'text',
                                file_name: message.file_name,
                                file_size: message.file_size,
                                file_type: message.file_type,
                                timestamp: message.timestamp,
                                sender_username: message.sender_username
                            };

                            if (normalized.message_type === 'file') {
                                addFileMessageToUI(normalized, normalized.sender_id === myId);
                            } else {
                                addMessageToUI(normalized);
                            }
                        });
                    }
                } else {
                    console.warn('Failed to fetch messages from server', resp.status);
                }
            } catch (err) {
                console.error('Error fetching conversation from server:', err);
            }
            };

            // After rendering history, send seen notifications for any incoming messages that are not marked seen
            try {
                if (wsConnection && wsConnection.readyState === WebSocket.OPEN) {
                    const toMark = [];
                    peerMessages.forEach(m => {
                        if (!m.is_outgoing && m.id && !m.seen) toMark.push(m.id);
                    });
                    if (toMark.length) {
                        wsConnection.send(JSON.stringify({ type: 'message_seen', message_ids: toMark }));
                        // mark locally
                        peerMessages.forEach(m => { if (!m.is_outgoing && m.id) m.seen = true; });
                        try { localStorage.setItem(`msg_history_${peerId}`, JSON.stringify(peerMessages)); } catch(e){}
                    }
                }
            } catch (err) { console.warn('Error sending seen batch', err); }

            scrollToBottom();
        

        // Load stored messages for a group and render them
        function loadGroupHistory(group) {
            if (!group || !group.id) return;
            chatMessages.innerHTML = '';

            const welcomeMsg = document.createElement('div');
            welcomeMsg.className = 'message incoming';
            welcomeMsg.innerHTML = `
        <div class="message-text">💬 Group: ${escapeHtml(group.name)} — ${(group.members || []).length} members</div>
        <div class="message-time">${new Date().toLocaleTimeString()}</div>
    `;
            chatMessages.appendChild(welcomeMsg);

            // Load persisted group history
            try {
                const key = `msg_history_group_${group.id}`;
                const raw = localStorage.getItem(key);
                let arr = [];
                if (raw) arr = JSON.parse(raw);
                // store in messageHistory under a group-specific key to avoid id clashes
                messageHistory[`group_${group.id}`] = arr || [];

                if (arr && arr.length) {
                    arr.forEach(message => {
                        if (message.type === 'file') addFileMessageToUI(message, message.is_outgoing);
                        else addMessageToUI(message);
                    });
                }
            } catch (err) {
                console.warn('Failed to load persisted group history', err);
            }

            // Sync with server
            if (wsConnection && wsConnection.readyState === WebSocket.OPEN) {
                wsConnection.send(JSON.stringify({ type: 'get_group_messages', group_id: group.id }));
            }

            scrollToBottom();
        }

        function closeProfilePanel() {
            const profilePanel = document.getElementById('profilePanel');
            if (profilePanel) {
                profilePanel.classList.remove('show');
                setTimeout(() => profilePanel.classList.add('hidden'), 300);
            }
        }

        function logoutUser() {
            if (wsConnection && wsConnection.readyState === WebSocket.OPEN) {
                wsConnection.close();
            }

            sessionStorage.removeItem('currentUser');
            sessionStorage.removeItem('isLoggedIn');
            sessionStorage.removeItem('loginTime');

            showNotification('Logged out successfully', 'success');
            setTimeout(() => {
                window.location.href = 'index.html';
            }, 1000);
        }

        function scrollToBottom() {
            try {
                // immediate attempt
                chatMessages.scrollTop = chatMessages.scrollHeight;
                // ensure after layout/images have rendered
                requestAnimationFrame(() => {
                    chatMessages.scrollTop = chatMessages.scrollHeight;
                    setTimeout(() => { chatMessages.scrollTop = chatMessages.scrollHeight; }, 60);
                });
            } catch (e) {
                // defensive fallback
                try { chatMessages.scrollTop = chatMessages.scrollHeight; } catch (_) {}
            }
        }

        function showNotification(message, type = 'info') {
            const existingNotifications = document.querySelectorAll('.custom-notification');
            existingNotifications.forEach(notification => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            });

            const notification = document.createElement('div');
            notification.className = 'custom-notification';
            notification.style.cssText = `
        position: fixed;
        top: 80px;
        right: 20px;
        background: ${type === 'error' ? '#e74c3c' : type === 'success' ? '#2ecc71' : '#0088cc'};
        color: white;
        padding: 12px 20px;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        z-index: 1000;
        max-width: 300px;
        font-weight: 500;
        transform: translateX(100%);
        transition: transform 0.3s ease;
    `;
            notification.textContent = message;
            document.body.appendChild(notification);

            setTimeout(() => {
                notification.style.transform = 'translateX(0)';
            }, 10);

            setTimeout(() => {
                if (notification.parentNode) {
                    notification.style.transform = 'translateX(100%)';
                    setTimeout(() => {
                        if (notification.parentNode) {
                            notification.parentNode.removeChild(notification);
                        }
                    }, 300);
                }
            }, 4000);
        }

        // Play a short notification sound using WebAudio
        function playNotificationSound(volumePercent = 80) {
            try {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                const ctx = new AudioContext();
                const o = ctx.createOscillator();
                const g = ctx.createGain();
                o.type = 'sine';
                o.frequency.setValueAtTime(880, ctx.currentTime);
                g.gain.setValueAtTime((volumePercent / 100) * 0.08, ctx.currentTime);
                o.connect(g);
                g.connect(ctx.destination);
                o.start();
                setTimeout(() => {
                    o.stop();
                    try { ctx.close(); } catch (e) { }
                }, 120);
            } catch (err) {
                try {
                    const audio = new Audio('data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEAESsAACJWAAACABAAZGF0YQAAAAA=');
                    audio.volume = (volumePercent / 100);
                    audio.play().catch(() => { });
                } catch (e) { }
            }
        }

        // Enhanced showNotification that can optionally play sound
        function showNotificationWithSound(message, type = 'info', playSound = false) {
            showNotification(message, type);
            try {
                const soundEnabled = JSON.parse(localStorage.getItem('soundNotifications') || 'true');
                const volume = parseInt(localStorage.getItem('notificationVolume') || '80', 10);
                if (playSound && soundEnabled) playNotificationSound(volume);
            } catch (err) { /* ignore */ }
        }

        // Check authentication
        if (!checkAuthentication()) {
            throw new Error('Authentication failed - redirecting to login');
        }

        // Create Group: modal logic, populate peers, submit via WebSocket
        // Create Group: modal logic, populate peers, submit via WebSocket
        let groupModalInitialized = false;

        function initializeGroupModal() {
            if (groupModalInitialized) return;

            const openBtn = document.getElementById('create-group');
            const modal = document.getElementById('createGroupModal');
            const closeBtn = document.getElementById('createGroupClose');
            const cancelBtn = document.getElementById('createGroupCancel');
            const submitBtn = document.getElementById('createGroupSubmit');
            const peersContainer = document.getElementById('create-group-peers');
            const nameInput = document.getElementById('groupName');

            if (openBtn) openBtn.addEventListener('click', (e) => { e.preventDefault(); showGroupModal(); });
            if (closeBtn) closeBtn.addEventListener('click', hideGroupModal);
            if (cancelBtn) cancelBtn.addEventListener('click', hideGroupModal);

            // Submit: collect selected usernames and send create_group over WebSocket
            if (submitBtn) submitBtn.addEventListener('click', (e) => {
                e.preventDefault();
                const name = nameInput && nameInput.value && nameInput.value.trim();
                if (!name) return showNotification('Please provide a group name', 'error');
                const checked = Array.from(peersContainer.querySelectorAll('input[type="checkbox"]:checked')).map(cb => cb.value);
                if (!checked.length) return showNotification('Select at least one participant', 'error');

                // Create a temporary group id so we can reconcile optimistic UI with server response
                const tempId = 'g_temp_' + Date.now();
                // include creator in optimistic members so UI shows correct member count/name
                const tempGroup = { id: tempId, name: name, members: [(currentUser && currentUser.username) || 'me'].concat(checked.slice()) };

                // Add temporary group locally immediately
                createGroupLocal(tempGroup);

                const payload = { type: 'create_group', group_name: name, members: checked, client_id: tempId };
                console.log('▶️ Sending create_group payload ->', payload);

                try {
                    if (wsConnection && wsConnection.readyState === WebSocket.OPEN) {
                        wsConnection.send(JSON.stringify(payload));
                        showNotification('Group creation sent', 'success');
                        console.log('✅ create_group sent (ws open)');
                    } else {
                        // optimistic local create when WS is unavailable
                        showNotification('Offline — group saved locally', 'info');
                        console.log('⚠️ WS closed — stored group locally (temp id)', tempGroup);
                    }
                } catch (err) { console.warn('Failed to send create_group', err); }

                hideGroupModal();
            });

            groupModalInitialized = true;
        }

        function showGroupModal() {
            const modal = document.getElementById('createGroupModal');
            const nameInput = document.getElementById('groupName');
            if (!modal) return;
            populateGroupPeersList();
            modal.style.display = 'flex';
            try { nameInput.focus(); } catch (e) { }
        }

        function hideGroupModal() {
            const modal = document.getElementById('createGroupModal');
            const nameInput = document.getElementById('groupName');
            const peersContainer = document.getElementById('create-group-peers');
            if (!modal) return;
            modal.style.display = 'none';
            // clear inputs
            if (nameInput) nameInput.value = '';
            if (peersContainer) peersContainer.innerHTML = '';
        }

        function populateGroupPeersList() {
            const peersContainer = document.getElementById('create-group-peers');
            if (!peersContainer) return;
            peersContainer.innerHTML = '';
            // Use friends/contacts when creating a group (prefer friends over discovered peers)
            const list = (Array.isArray(window.friends) && window.friends.length) ? window.friends : ((peers && peers.length) ? peers : []);
            // exclude self if possible
            const me = currentUser && currentUser.username;
            if (list.length === 0) {
                const note = document.createElement('div');
                note.textContent = 'No peers available. Try Discover Peers or wait for peers to connect.';
                note.style.color = '#666';
                peersContainer.appendChild(note);
                return;
            }
            list.forEach(p => {
                if (p.username === me) return; // don't include self
                const row = document.createElement('label');
                row.style.display = 'flex';
                row.style.alignItems = 'center';
                row.style.gap = '8px';
                row.style.padding = '6px';
                row.style.cursor = 'pointer';

                const cb = document.createElement('input');
                cb.type = 'checkbox';
                cb.value = p.username;
                cb.dataset.userid = p.user_id || '';

                const avatar = document.createElement('img');
                avatar.src = p.avatar || `https://i.pravatar.cc/40?u=${encodeURIComponent(p.username)}`;
                avatar.style.width = '32px';
                avatar.style.height = '32px';
                avatar.style.borderRadius = '50%';

                const span = document.createElement('span');
                span.textContent = p.username + (p.is_online ? ' (online)' : ' (offline)');
                span.style.marginLeft = '6px';

                row.appendChild(cb);
                row.appendChild(avatar);
                row.appendChild(span);
                peersContainer.appendChild(row);
            });
        }

        function createGroupLocal(group) {
            // push to local groups list and add entry to sidebar
            groups = groups || [];
            // avoid duplicates
            const exists = groups.find(g => String(g.id) === String(group.id));
            if (!exists) groups.push(group);

            // Re-render groups list if we are on the groups tab
            // or explicitly update the list
            persistGroups();
            renderGroupsList();
        }

        function persistGroups() {
            try { localStorage.setItem('p2p_groups', JSON.stringify(groups || [])); } catch (e) { console.warn('persistGroups error', e); }
        }

        function loadGroupsFromStorage() {
            try {
                const raw = localStorage.getItem('p2p_groups');
                if (!raw) return;
                const saved = JSON.parse(raw);
                if (!Array.isArray(saved)) return;
                groups = saved;
                // Render groups in sidebar
                renderGroupsList();
            } catch (err) { console.warn('loadGroupsFromStorage failed', err); }
        }

        function renderGroupsList() {
            console.log('🔄 renderGroupsList called');
            const container = document.getElementById('groups-list');
            if (!container) {
                console.warn('❌ groups-list container not found');
                return;
            }

            // Get groups from global variable or storage
            if (!groups || groups.length === 0) {
                try {
                    const raw = localStorage.getItem('p2p_groups');
                    if (raw) groups = JSON.parse(raw);
                } catch (e) { }
            }

            if (!groups || groups.length === 0) {
                console.log('⚠️ No groups to render');
                container.innerHTML = '<li class="empty-state">No groups yet. Create one!</li>';
                return;
            }

            container.innerHTML = groups.slice().reverse().map(group => {
                const memberCount = group.members ? group.members.length : 0;
                const groupName = group.name || group.group_name || 'Unnamed Group';
                const groupId = group.id || group.group_id;

                return `
                    <li class="contact-item group-item" data-group-id="${groupId}" data-group-name="${groupName}">
                        <div class="avatar">
                            <img src="https://ui-avatars.com/api/?name=${encodeURIComponent(groupName)}&background=0084ff&color=fff&size=50" 
                                 alt="${groupName}" style="border-radius: 50%;">
                        </div>
                        <div class="meta">
                            <div class="peer-name">
                                ${groupName}
                            </div>
                            <div class="peer-sub">${memberCount} member${memberCount !== 1 ? 's' : ''}</div>
                        </div>
                    </li>
                `;
            }).join('');

            // Add click handlers
            container.querySelectorAll('.group-item').forEach(item => {
                item.addEventListener('click', function () {
                    const groupId = this.dataset.groupId;
                    // Find group object
                    const group = groups.find(g => String(g.id) === String(groupId));
                    if (group) {
                        openGroupChat(group);
                    }
                });
            });

            console.log('✅ renderGroupsList() completed');
        }

        function openGroupChat(group) {
            if (!group) return;
            // membership check: if user is not a member, show join prompt instead of opening
            function isUserInGroup(g) {
                try {
                    const uid = currentUser?.id || currentUser?.user_id || currentUser?.userId;
                    const uname = currentUser?.username || currentUser?.name || currentUser?.user;
                    if (!g) return false;
                    const members = g.members || [];
                    if (!Array.isArray(members) || members.length === 0) return false;
                    // members may be simple usernames, ids, or objects { user_id, username }
                    return members.some(m => {
                        if (m == null) return false;
                        if (typeof m === 'number' || /^[0-9]+$/.test(String(m))) return String(m) === String(uid);
                        if (typeof m === 'string') return String(m) === String(uname) || String(m) === String(uid);
                        if (typeof m === 'object') {
                            return String(m.user_id || m.id) === String(uid) || String(m.username || m.name) === String(uname);
                        }
                        return false;
                    });
                } catch (e) { return false; }
            }

            if (!isUserInGroup(group)) {
                // Show join prompt instead of opening chat
                showJoinGroupPrompt(group);
                return;
            }

            currentGroup = group;
            currentPeer = {
                group_id: group.id,
                name: group.name,
                is_group: true
            }; // Special peer object for group

            const chatWithEl = document.getElementById('chat-with');
            const groupIndicator = document.getElementById('group-indicator');
            const chatAvatar = document.querySelector('.chat-header .user-avatar img') || document.getElementById('chat-avatar');

            if (chatWithEl) chatWithEl.textContent = group.name;
            if (groupIndicator) groupIndicator.classList.remove('hidden');

            // Set group avatar in chat header
            if (chatAvatar) {
                chatAvatar.src = `https://ui-avatars.com/api/?name=${encodeURIComponent(group.name)}&background=0084ff&color=fff&size=50`;
            }

            // show chat page
            const emptyView = document.getElementById('empty-view');
            const chatPage = document.getElementById('chat-page');
            if (emptyView) emptyView.classList.add('hidden');
            if (chatPage) chatPage.classList.remove('hidden');

            // Load group message history
            try { loadGroupHistory(group); } catch (err) { console.warn('Failed to load group history', err); }
            // Show group-specific header actions
            try {
                const addAction = document.getElementById('addMembersAction'); if (addAction) addAction.style.display = 'block';
                const viewAction = document.getElementById('viewGroupInfoAction'); if (viewAction) viewAction.style.display = 'block';
                const groupIndicator = document.getElementById('group-indicator'); if (groupIndicator) groupIndicator.classList.remove('hidden');
            } catch (e) { /* ignore */ }
            // show the More button/menu for groups
            try {
                const moreBtn = document.getElementById('chatMoreBtn'); if (moreBtn) moreBtn.style.display = 'inline-block';
                const moreMenu = document.getElementById('chatMoreMenu'); if (moreMenu) moreMenu.style.display = 'none';
            } catch (e) { /* ignore */ }
            showNotification(`Opened group: ${group.name}`, 'success');
        }

        // Show a small join prompt for non-members before allowing them to open the group
        function showJoinGroupPrompt(group) {
            if (!group) return;
            // remove existing prompt if any
            const existing = document.getElementById('joinGroupPrompt');
            if (existing) existing.remove();

            const modal = document.createElement('div');
            modal.id = 'joinGroupPrompt';
            modal.className = 'modal';
            modal.style.cssText = 'display:flex;align-items:center;justify-content:center;position:fixed;left:0;top:0;right:0;bottom:0;z-index:1200;background:rgba(0,0,0,0.4);';

            const html = `
                <div class="modal-content" style="max-width:520px;padding:18px;border-radius:8px;background:#fff;">
                    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
                        <div>
                            <div style="font-weight:700;font-size:16px;">Join Group</div>
                            <div style="font-size:13px;color:#666;margin-top:6px;">Tap to join a chat group</div>
                        </div>
                        <button id="joinGroupClose" class="btn" style="background:none;border:none;font-size:20px;">&times;</button>
                    </div>
                    <div style="margin:8px 0 16px;color:#333;">You are not a member of <strong>${escapeHtml(group.name)}</strong>. Join to participate and view members.</div>
                    <div style="display:flex;gap:8px;justify-content:flex-end;">
                        <button id="joinGroupCancel" class="btn" style="background:#f0f0f0;color:#111;padding:8px 12px;border-radius:6px;">Close</button>
                        <button id="joinGroupConfirm" class="btn btn-primary" title="Join to Chat & View Members • Join Group to Participate • Become a Member to Chat" style="padding:8px 12px;border-radius:6px;">Join Group</button>
                    </div>
                </div>
            `;

            modal.innerHTML = html;
            document.body.appendChild(modal);

            // close handlers
            document.getElementById('joinGroupClose').addEventListener('click', () => modal.remove());
            document.getElementById('joinGroupCancel').addEventListener('click', () => modal.remove());

            document.getElementById('joinGroupConfirm').addEventListener('click', async (e) => {
                const btn = e.currentTarget;
                btn.disabled = true;
                btn.textContent = 'Joining...';
                try {
                    if (wsConnection && wsConnection.readyState === WebSocket.OPEN) {
                        wsConnection.send(JSON.stringify({ type: 'join_group', group_id: group.id }));
                        showNotification('Joining group...', 'info');
                    } else {
                        // fallback to REST join if WebSocket unavailable
                        try {
                            await fetch(`${API_URL}/groups/join`, {
                                method: 'POST', headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ group_id: group.id })
                            });
                            showNotification('Join request sent', 'info');
                        } catch (err) {
                            showNotification('Unable to join group (offline)', 'error');
                        }
                    }
                    // Optimistically open the group chat immediately so user lands in chat area
                    try {
                        // Ensure members array exists and add current user locally for UI
                        group.members = group.members || [];
                        const uid = currentUser?.id || currentUser?.user_id || null;
                        const uname = currentUser?.username || currentUser?.name || null;
                        const already = group.members.some(m => {
                            if (!m) return false;
                            if (typeof m === 'string') return String(m) === String(uname) || String(m) === String(uid);
                            if (typeof m === 'object') return String(m.user_id || m.id) === String(uid) || String(m.username || m.name) === String(uname);
                            return false;
                        });
                        if (!already && (uid || uname)) {
                            group.members.push({ user_id: uid, username: uname });
                        }
                        // set pending open and open now
                        pendingOpenGroupId = group.id;
                        openGroupChat(group);
                    } catch (err) { console.warn('Optimistic open failed', err); }
                } catch (err) {
                    console.warn('Join group failed', err);
                } finally {
                    // close the prompt after a short delay to allow transition
                    setTimeout(() => modal.remove(), 300);
                }
            });
        }

        function escapeHtml(s) { return String(s).replace(/[&<>"']/g, function (m) { return { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }[m]; }); }




        // Debug function
        window.debugP2P = function () {
            console.log('=== P2P CHAT DEBUG INFO ===');
            console.log('Current User:', currentUser);
            console.log('WebSocket State:', wsConnection ? wsConnection.readyState : 'No connection');
            console.log('Current Peer:', currentPeer);
            console.log('All Peers:', peers);
            console.log('API URL:', API_URL);
            console.log('WS URL:', WS_URL);
            console.log('==========================');
        };

        console.log('🔧 Debug functions available: window.debugP2P()');</script>

    <script>
    // Add-members client logic: open menu, show modal, send add_group_members
    (function(){
        function el(id){return document.getElementById(id)}

        // Toggle more menu
        document.addEventListener('click', (e)=>{
            const moreBtn = el('chatMoreBtn');
            const menu = el('chatMoreMenu');
            if(!moreBtn || !menu) return;
            if(e.target === moreBtn || moreBtn.contains(e.target)){
                // toggle
                menu.style.display = (menu.style.display === 'block') ? 'none' : 'block';
                return;
            }
            // click outside -> hide
            if(!menu.contains(e.target)) menu.style.display = 'none';
        });

        // Open add-members modal from menu
        document.addEventListener('DOMContentLoaded', ()=>{
            const addAction = el('addMembersAction');
            if(addAction) addAction.addEventListener('click', ()=>{
                const menu = el('chatMoreMenu'); if(menu) menu.style.display='none';
                openAddMembersModal();
            });

            // Wire modal buttons
            const closeBtn = el('addMembersClose'); if(closeBtn) closeBtn.addEventListener('click', closeAddMembersModal);
            const cancelBtn = el('addMembersCancel'); if(cancelBtn) cancelBtn.addEventListener('click', closeAddMembersModal);
            const submitBtn = el('addMembersSubmit'); if(submitBtn) submitBtn.addEventListener('click', submitAddMembers);
            const search = el('addMembersSearch'); if(search) search.addEventListener('input', filterAddMembersList);
            // Discover groups button wiring
            const discoverBtn = el('discover-groups'); if(discoverBtn) discoverBtn.addEventListener('click', ()=>{ openDiscoverGroupsModal(); });
            const discoverClose = el('discoverGroupsClose'); if(discoverClose) discoverClose.addEventListener('click', closeDiscoverGroupsModal);
            const discoverCancel = el('discoverGroupsCancel'); if(discoverCancel) discoverCancel.addEventListener('click', closeDiscoverGroupsModal);
            const discoverSearch = el('discoverGroupsSearch'); if(discoverSearch) discoverSearch.addEventListener('input', filterDiscoverGroupsList);
        });

        function openAddMembersModal(){
            const dlg = el('addMembersModal'); if(!dlg) return; dlg.style.display = 'flex';
            renderAddMembersList();
            const s = el('addMembersSearch'); if(s) s.value='';
        }

        function closeAddMembersModal(){
            const dlg = el('addMembersModal'); if(!dlg) return; dlg.style.display = 'none';
            const list = el('add-members-list'); if(list) list.innerHTML='';
        }

        function renderAddMembersList(){
            const container = el('add-members-list'); if(!container) return; container.innerHTML='';
            // Only show friends/contacts for adding to a group (do not include allUsers)
            const source = Array.isArray(window.friends) ? window.friends.slice() : [];

            if (!source.length) { container.innerHTML = '<div class="empty-state">No friends available to add</div>'; return; }

            // Build list, disabling items already in the group
            const existingMembers = new Set((currentGroup && Array.isArray(currentGroup.members)) ? currentGroup.members.map(m => String(m)) : []);
            const me = (currentUser && (currentUser.user_id || currentUser.id || currentUser.username)) || null;

            source.forEach(u => {
                const username = u.username || u.name || u.user_name || '';
                const userId = u.user_id || u.id || username;
                if (String(userId) === String(me)) return; // don't include self

                const row = document.createElement('label');
                row.className = 'friend-select-item';
                row.style.display = 'flex';
                row.style.alignItems = 'center';
                row.style.gap = '10px';
                row.style.padding = '6px';

                const cb = document.createElement('input');
                cb.type = 'checkbox';
                cb.value = username;
                cb.dataset.userId = userId;

                // If already a member, disable the checkbox and mark
                if (existingMembers.has(String(userId))) {
                    cb.disabled = true;
                    const note = document.createElement('span'); note.textContent = ' (already in group)'; note.style.fontSize = '12px'; note.style.color = '#666';
                    const avatar = document.createElement('img'); avatar.src = (u.avatar_url || u.avatar || ''); avatar.style.width = '36px'; avatar.style.height = '36px'; avatar.style.borderRadius = '50%'; avatar.style.objectFit = 'cover';
                    const nameEl = document.createElement('div'); nameEl.className = 'name'; nameEl.innerText = username || ('id:' + userId);
                    row.appendChild(cb); row.appendChild(avatar); row.appendChild(nameEl); row.appendChild(note);
                } else {
                    const avatar = document.createElement('img'); avatar.src = (u.avatar_url || u.avatar || ''); avatar.style.width = '36px'; avatar.style.height = '36px'; avatar.style.borderRadius = '50%'; avatar.style.objectFit = 'cover';
                    const nameEl = document.createElement('div'); nameEl.className = 'name'; nameEl.innerText = username || ('id:' + userId);
                    row.appendChild(cb); row.appendChild(avatar); row.appendChild(nameEl);
                }

                container.appendChild(row);
            });
        }

        function filterAddMembersList(e){
            const q = (e.target.value||'').toLowerCase();
            const container = el('add-members-list'); if(!container) return;
            Array.from(container.children).forEach(row=>{
                const txt = (row.innerText||'').toLowerCase();
                row.style.display = txt.indexOf(q) === -1 ? 'none' : 'flex';
            });
        }

        function submitAddMembers(){
            const container = el('add-members-list'); if(!container) return;
            const checks = Array.from(container.querySelectorAll('input[type=checkbox]:checked'));
            if(!checks.length){ alert('Select at least one user to add'); return; }

            // group id determination
            let gid = null;
            if(currentGroup && (currentGroup.id || currentGroup.group_id)) gid = currentGroup.id || currentGroup.group_id;
            else if(currentPeer && currentPeer.group_id) gid = currentPeer.group_id;
            if(!gid){ alert('No group selected'); return; }

            const members = checks.map(cb => cb.dataset.userId || cb.value);
            const payload = { type: 'add_group_members', group_id: gid, members: members, client_id: 'agm_' + Date.now() };

            try{
                if(window.wsConnection && window.wsConnection.readyState === 1){ window.wsConnection.send(JSON.stringify(payload)); }
                else if(window.socket && window.socket.readyState === 1){ window.socket.send(JSON.stringify(payload)); }
                else { alert('Not connected to server'); return; }
            }catch(e){ console.error('Failed to send add_group_members', e); alert('Failed to send request'); return; }

            // optimistic local update: add to currentGroup.members if present
            try{
                if(currentGroup){
                    currentGroup.members = currentGroup.members || [];
                    members.forEach(m=>{ if(!currentGroup.members.includes(m)) currentGroup.members.push(m); });
                    // persist groups to localStorage if used
                    try{ const raw = localStorage.getItem('p2p_groups'); if(raw){ const gs = JSON.parse(raw); const g = gs.find(x=>String(x.id)===String(gid)); if(g){ members.forEach(m=>{ if(!g.members) g.members=[]; if(!g.members.includes(m)) g.members.push(m); }); localStorage.setItem('p2p_groups', JSON.stringify(gs)); } }
                    }catch(_){ }
                }
            }catch(_){ }

            closeAddMembersModal();
            if(typeof showNotification === 'function') showNotification('Add members request sent', 'success');
        }

        // Discover groups logic
        function openDiscoverGroupsModal(){
            const dlg = el('discoverGroupsModal'); if(!dlg) return; dlg.style.display = 'flex';
            const list = el('discover-groups-list'); if(list) list.innerHTML = '<div class="empty-state">Loading groups...</div>';
            // request public groups from server
            const payload = { type: 'get_public_groups' };
            try{ if(window.wsConnection && window.wsConnection.readyState === 1) window.wsConnection.send(JSON.stringify(payload)); else if(window.socket && window.socket.readyState === 1) window.socket.send(JSON.stringify(payload)); }
            catch(e){ console.warn('Failed to request public groups', e); if(list) list.innerHTML = '<div class="empty-state">Failed to load groups</div>'; }
        }

        function closeDiscoverGroupsModal(){ const dlg = el('discoverGroupsModal'); if(!dlg) return; dlg.style.display='none'; const list = el('discover-groups-list'); if(list) list.innerHTML=''; }

        function renderDiscoverGroupsList(groups){
            const container = el('discover-groups-list'); if(!container) return; container.innerHTML='';
            if(!Array.isArray(groups) || groups.length === 0){ container.innerHTML = '<div class="empty-state">No groups found</div>'; return; }
            groups.forEach(g => {
                const row = document.createElement('div'); row.style.display='flex'; row.style.alignItems='center'; row.style.justifyContent='space-between'; row.style.padding='8px'; row.style.borderBottom='1px solid #f1f1f1';
                const left = document.createElement('div'); left.style.display='flex'; left.style.alignItems='center'; left.style.gap='10px';
                const avatar = document.createElement('img'); avatar.src = `https://ui-avatars.com/api/?name=${encodeURIComponent(g.name||'Group')}&background=0084ff&color=fff&size=40`; avatar.style.width='40px'; avatar.style.height='40px'; avatar.style.borderRadius='50%';
                const meta = document.createElement('div'); meta.innerHTML = `<div style="font-weight:600">${escapeHtml(g.name||'Unnamed')}</div><div style="font-size:12px;color:#666">${(g.member_count||0)} member${(g.member_count||0)!==1?'s':''}</div>`;
                left.appendChild(avatar); left.appendChild(meta);
                const actions = document.createElement('div');
                const joinBtn = document.createElement('button');
                joinBtn.className = 'btn';
                joinBtn.style.minWidth = '110px';
                // Main label + small subtitle for clarity
                joinBtn.innerHTML = `Join Group<br><small style="font-size:11px;color:#fff;opacity:0.9">Tap to join a chat group</small>`;
                // Tooltip includes alternative phrasing options
                joinBtn.title = 'Join to Chat & View Members • Join Group to Participate • Become a Member to Chat';
                joinBtn.addEventListener('click', () => { joinGroup(g.id, joinBtn); });
                actions.appendChild(joinBtn);
                row.appendChild(left); row.appendChild(actions);
                container.appendChild(row);
            });
        }

        function filterDiscoverGroupsList(e){ const q = (e.target.value||'').toLowerCase(); const container = el('discover-groups-list'); if(!container) return; Array.from(container.children).forEach(row=>{ const txt = (row.innerText||'').toLowerCase(); row.style.display = txt.indexOf(q) === -1 ? 'none' : 'flex'; }); }

        function joinGroup(groupId, btn){ if(!groupId) return; if(btn) { btn.disabled = true; btn.textContent = 'Joining...'; }
            const payload = { type: 'join_group', group_id: groupId };
            try{ if(window.wsConnection && window.wsConnection.readyState === 1) window.wsConnection.send(JSON.stringify(payload)); else if(window.socket && window.socket.readyState === 1) window.socket.send(JSON.stringify(payload)); else { if(btn){ btn.disabled=false; btn.textContent='Join'; } alert('Not connected'); } }
            catch(e){ console.error('joinGroup send failed', e); if(btn){ btn.disabled=false; btn.textContent='Join'; } alert('Failed to send join request'); }
        }
        // Expose discover functions to global scope so the global WS handler can call them
        try{ window.renderDiscoverGroupsList = renderDiscoverGroupsList; window.openDiscoverGroupsModal = openDiscoverGroupsModal; window.joinGroup = joinGroup; }catch(e){}

        // Hook responses from server in the global message handler
    })();
    </script>
</body>

</html>
<!--
# python3
import asyncio, websockets
async def t(): 
    async with websockets.connect('ws://192.168.137.109:8766') as ws:
        await ws.send('{"type":"ping"}')
        print(await ws.recv())
asyncio.run(t())
-->